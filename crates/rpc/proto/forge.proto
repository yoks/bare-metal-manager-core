syntax = "proto3";

package forge;

// Don't forget to update build.rs to add the Serialize annotation for any new
// message types!

import "common.proto";
import "dns.proto";
import "dpa_rpc.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";
import "health.proto";
import "machine_discovery.proto";
import "measured_boot.proto";
import "mlx_device.proto";
import "site_explorer.proto";

service Forge {
  // What version of Forge is this service running? Matches `--version` command line.
  rpc Version(VersionRequest) returns (BuildInfo);

  // Domain
  rpc CreateDomain(dns.CreateDomainRequest) returns (dns.Domain);
  rpc UpdateDomain(dns.UpdateDomainRequest) returns (dns.Domain);
  rpc DeleteDomain(dns.DomainDeletionRequest)
      returns (dns.DomainDeletionResult);
  rpc FindDomain(dns.DomainSearchQuery) returns (dns.DomainList);

  // DEPRECATED Domain RPCs - for backward compatibility
  // Use the non-Legacy versions above instead
  rpc CreateDomainLegacy(DomainLegacy) returns (DomainLegacy) {
    option deprecated = true;
  }
  rpc UpdateDomainLegacy(DomainLegacy) returns (DomainLegacy) {
    option deprecated = true;
  }
  rpc DeleteDomainLegacy(DomainDeletionLegacy)
      returns (DomainDeletionResultLegacy) {
    option deprecated = true;
  }
  rpc FindDomainLegacy(DomainSearchQueryLegacy) returns (DomainListLegacy) {
    option deprecated = true;
  }

  // VPC
  rpc CreateVpc(VpcCreationRequest) returns (Vpc);
  rpc UpdateVpc(VpcUpdateRequest) returns (VpcUpdateResult);
  rpc UpdateVpcVirtualization(VpcUpdateVirtualizationRequest) returns (VpcUpdateVirtualizationResult);
  rpc DeleteVpc(VpcDeletionRequest) returns (VpcDeletionResult);
  rpc FindVpcIds(VpcSearchFilter) returns (VpcIdList);
  rpc FindVpcsByIds(VpcsByIdsRequest) returns (VpcList);

  // VPC prefixes
  rpc CreateVpcPrefix(VpcPrefixCreationRequest) returns (VpcPrefix);
  rpc SearchVpcPrefixes(VpcPrefixSearchQuery) returns (VpcPrefixIdList);
  rpc GetVpcPrefixes(VpcPrefixGetRequest) returns (VpcPrefixList);
  rpc UpdateVpcPrefix(VpcPrefixUpdateRequest) returns (VpcPrefix);
  rpc DeleteVpcPrefix(VpcPrefixDeletionRequest) returns (VpcPrefixDeletionResult);

  // VPC peering
  rpc CreateVpcPeering(VpcPeeringCreationRequest) returns (VpcPeering);
  rpc FindVpcPeeringIds(VpcPeeringSearchFilter) returns (VpcPeeringIdList);
  rpc FindVpcPeeringsByIds(VpcPeeringsByIdsRequest) returns (VpcPeeringList);
  rpc DeleteVpcPeering(VpcPeeringDeletionRequest) returns (VpcPeeringDeletionResult);

  // Segments - i.e. Overlay Networks
  rpc FindNetworkSegmentIds(NetworkSegmentSearchFilter) returns (NetworkSegmentIdList);
  rpc FindNetworkSegmentsByIds(NetworkSegmentsByIdsRequest) returns (NetworkSegmentList);
  rpc CreateNetworkSegment(NetworkSegmentCreationRequest) returns (NetworkSegment);
  rpc DeleteNetworkSegment(NetworkSegmentDeletionRequest) returns (NetworkSegmentDeletionResult);
  // TODO: This functionality should get integrated into NetworkSegmentSearchFilter
  rpc NetworkSegmentsForVpc(VpcSearchQuery) returns (NetworkSegmentList);

  // InfiniBand Partitions
  rpc FindIBPartitionIds(IBPartitionSearchFilter) returns (IBPartitionIdList);
  rpc FindIBPartitionsByIds(IBPartitionsByIdsRequest) returns (IBPartitionList);
  // Create a IB partition
  rpc CreateIBPartition(IBPartitionCreationRequest) returns (IBPartition);
  // Delete a IB partition
  rpc DeleteIBPartition(IBPartitionDeletionRequest) returns (IBPartitionDeletionResult);
  // Find all IB partitions under a specified tenant
  rpc IBPartitionsForTenant(TenantSearchQuery) returns (IBPartitionList);

  rpc FindPowerShelves(PowerShelfQuery) returns (PowerShelfList);
  rpc DeletePowerShelf(PowerShelfDeletionRequest) returns (PowerShelfDeletionResult);

  rpc FindSwitches(SwitchQuery) returns (SwitchList);
  rpc DeleteSwitch(SwitchDeletionRequest) returns (SwitchDeletionResult);

  // InfiniBand Fabrics
  // Returns the list of all InfiniBand fabrics available within the site
  rpc FindIBFabricIds(IBFabricSearchFilter) returns (IBFabricIdList);

  // Manage instances on machines
  // Allocates a Machine as Instance for tenant, with the given configuration
  rpc AllocateInstance(InstanceAllocationRequest) returns (Instance);
  // Allocates multiple Machines as Instances for tenant in a single transaction
  rpc AllocateInstances(BatchInstanceAllocationRequest) returns (BatchInstanceAllocationResponse);
  // Releases an instance that has been allocated by a tenant
  rpc ReleaseInstance(InstanceReleaseRequest) returns (InstanceReleaseResult);
  // Updates the network interface configuration for an instance
  // The update will take effect asynchronously. Users should monitor `Instance.status.network_status.synced`
  // to determine whether all updates have been applied.
  // Note: This is commented because we will not immediately implement the method
  // rpc UpdateInstanceNetworkConfig(InstanceNetworkConfigUpdateRequest) returns (Instance);
  // Updates the Operating System on a running instance
  rpc UpdateInstanceOperatingSystem(InstanceOperatingSystemUpdateRequest) returns (Instance);
  // Updates the configuration of a running instance.
  // Only the following configurations of an instance can be changed:
  // - Keyset IDs
  // - Metadata (Name, Description, Labels)
  // - Operating System Details
  // The update will take effect asynchronously. Users should monitor `Instance.status.synced`
  // to determine whether all updates have been applied.
  rpc UpdateInstanceConfig(InstanceConfigUpdateRequest) returns (Instance);

  rpc FindInstanceIds(InstanceSearchFilter) returns (InstanceIdList);
  rpc FindInstancesByIds(InstancesByIdsRequest) returns (InstanceList);
  rpc FindInstanceByMachineID(common.MachineId) returns (InstanceList);

  // forge-dpu-agent -> carbide-api
  rpc GetManagedHostNetworkConfig(ManagedHostNetworkConfigRequest) returns (ManagedHostNetworkConfigResponse);
  rpc RecordDpuNetworkStatus(DpuNetworkStatus) returns (google.protobuf.Empty);
  rpc RecordHardwareHealthReport(HardwareHealthReport) returns (google.protobuf.Empty);
  rpc GetHardwareHealthReport(common.MachineId) returns (OptionalHealthReport);
  rpc RecordLogParserHealthReport(HardwareHealthReport) returns (google.protobuf.Empty);
  // Lists all overrides that have been placed on a Machine health status
  rpc ListHealthReportOverrides(common.MachineId) returns (ListHealthReportOverrideResponse);
  // Adds a new override for a Machines health status
  rpc InsertHealthReportOverride(InsertHealthReportOverrideRequest) returns (google.protobuf.Empty);
  // Removes a health report override
  rpc RemoveHealthReportOverride(RemoveHealthReportOverrideRequest) returns (google.protobuf.Empty);
  // Lists all overrides that have been placed on a Rack health status (stub - implementation TBD)
  rpc ListRackHealthReportOverrides(ListRackHealthReportOverridesRequest) returns (ListHealthReportOverrideResponse);
  // Adds a new health report override for a Rack (stub - implementation TBD)
  rpc InsertRackHealthReportOverride(InsertRackHealthReportOverrideRequest) returns (google.protobuf.Empty);
  // Removes a health report override for a Rack (stub - implementation TBD)
  rpc RemoveRackHealthReportOverride(RemoveRackHealthReportOverrideRequest) returns (google.protobuf.Empty);
  rpc DpuAgentUpgradeCheck(DpuAgentUpgradeCheckRequest) returns (DpuAgentUpgradeCheckResponse);
  rpc DpuAgentUpgradePolicyAction(DpuAgentUpgradePolicyRequest) returns (DpuAgentUpgradePolicyResponse);
  // Looks up a DNS record for DNS names assigned by Forge
  rpc LookupRecord(dns.DnsResourceRecordLookupRequest)returns (dns.DnsResourceRecordLookupResponse);

  // DEPRECATED DNS Lookup RPC - for backward compatibility
  // Use LookupRecord with DnsResourceRecordLookupRequest instead
  rpc LookupRecordLegacy(DNSMessage.DNSQuestion)returns (DNSMessage.DNSResponse) {
    option deprecated = true;
  }

  // Get all DNS domains
  rpc GetAllDomains(dns.GetAllDomainsRequest) returns (dns.GetAllDomainsResponse);
  // Get metadata for a specific DNS domain
  rpc GetAllDomainMetadata(dns.DomainMetadataRequest) returns (dns.DomainMetadataResponse);

  // TODO(ajf): Harder to implement bi-directional streaming, commented out for now
  // rpc StreamConsole(stream ConsoleInput) returns (stream ConsoleOutput);
  // rpc StreamInstanceEvents(UUID) returns (stream InstanceEvent);

  /* Power Control */
  rpc InvokeInstancePower(InstancePowerRequest) returns (InstancePowerResult);

  rpc ForgeAgentControl(ForgeAgentControlRequest) returns (ForgeAgentControlResponse);
  // PRIVILEGED: Creates a new machine from nothing
  rpc DiscoverMachine(MachineDiscoveryInfo) returns (MachineDiscoveryResult);
  rpc RenewMachineCertificate(MachineCertificateRenewRequest) returns (MachineCertificateResult);
  rpc DiscoveryCompleted(MachineDiscoveryCompletedRequest) returns (MachineDiscoveryCompletedResponse);
  rpc CleanupMachineCompleted(MachineCleanupInfo) returns (MachineCleanupResult);
  // Invoked by forge-scout whenever a certain Machine can not be properly acted on
  rpc ReportForgeScoutError(ForgeScoutErrorReport) returns (ForgeScoutErrorReportResult);
  rpc DiscoverDhcp(DhcpDiscovery) returns (DhcpRecord);

  // PRIVILEGED: Find things
  rpc FindInterfaces(InterfaceSearchQuery) returns (InterfaceList);
  rpc DeleteInterface(InterfaceDeleteQuery) returns (google.protobuf.Empty);
  rpc FindIpAddress(FindIpAddressRequest) returns (FindIpAddressResponse);
  rpc FindMachineIds(MachineSearchConfig) returns (common.MachineIdList);
  rpc FindMachinesByIds(MachinesByIdsRequest) returns (MachineList);
  rpc FindMachineStateHistories(MachineStateHistoriesRequest) returns (MachineStateHistories);
  rpc FindMachineHealthHistories(MachineHealthHistoriesRequest) returns (MachineHealthHistories);
  rpc FindPowerShelfStateHistories(PowerShelfStateHistoriesRequest) returns (PowerShelfStateHistories);
  rpc FindSwitchStateHistories(SwitchStateHistoriesRequest) returns (SwitchStateHistories);
  rpc FindTenantOrganizationIds(TenantSearchFilter) returns (TenantOrganizationIdList);
  rpc FindTenantsByOrganizationIds(TenantByOrganizationIdsRequest) returns (TenantList);
  rpc FindConnectedDevicesByDpuMachineIds(common.MachineIdList) returns (ConnectedDeviceList);
  rpc FindMachineIdsByBmcIps(BmcIpList) returns (MachineIdBmcIpPairs);
  rpc FindMacAddressByBmcIp(BmcIp) returns (MacAddressBmcIp);
  rpc IdentifyUuid(IdentifyUuidRequest) returns (IdentifyUuidResponse);
  rpc IdentifyMac(IdentifyMacRequest) returns (IdentifyMacResponse);
  rpc IdentifySerial(IdentifySerialRequest) returns (IdentifySerialResponse);

  // IPMI handling
  rpc GetBMCMetaData(BMCMetaDataGetRequest) returns (BMCMetaDataGetResponse);

  // User Credential handling.
  rpc UpdateMachineCredentials(MachineCredentialsUpdateRequest) returns (MachineCredentialsUpdateResponse);

  rpc GetPxeInstructions(PxeInstructionRequest) returns (PxeInstructions);
  rpc GetCloudInitInstructions(CloudInitInstructionsRequest) returns (CloudInitInstructions);
  rpc Echo(EchoRequest) returns (EchoResponse);

  // Tenant, Tenant Team, & Tenant Public Key actions
  rpc CreateTenant(CreateTenantRequest) returns (CreateTenantResponse);
  rpc FindTenant(FindTenantRequest) returns (FindTenantResponse);
  rpc UpdateTenant(UpdateTenantRequest) returns (UpdateTenantResponse);

  rpc CreateTenantKeyset(CreateTenantKeysetRequest) returns (CreateTenantKeysetResponse);
  rpc FindTenantKeysetIds(TenantKeysetSearchFilter) returns (TenantKeysetIdList);
  rpc FindTenantKeysetsByIds(TenantKeysetsByIdsRequest) returns (TenantKeySetList);
  rpc UpdateTenantKeyset(UpdateTenantKeysetRequest) returns (UpdateTenantKeysetResponse);
  rpc DeleteTenantKeyset(DeleteTenantKeysetRequest) returns (DeleteTenantKeysetResponse);

  rpc ValidateTenantPublicKey(ValidateTenantPublicKeyRequest) returns (ValidateTenantPublicKeyResponse);

  // Admin CLI actions

  // Query Vault for the DPU's SSH admin password
  rpc GetDpuSSHCredential(CredentialRequest) returns (CredentialResponse);

  // List all machines network status (HBN), as reported by `forge-dpu-agent`
  rpc GetAllManagedHostNetworkStatus(ManagedHostNetworkStatusRequest) returns (ManagedHostNetworkStatusResponse);

  // Gets the latest Site Exploration report
  // DEPRECATED: use FindExploredEndpointIds, FindExploredEndpointsByIds and FindExploredManagedHostIds, FindExploredManagedHostsByIds instead
  rpc GetSiteExplorationReport(GetSiteExplorationRequest) returns (site_explorer.SiteExplorationReport);
  // Clear the last known error for the BMC
  rpc ClearSiteExplorationError(ClearSiteExplorationErrorRequest) returns (google.protobuf.Empty);
  // IsBmcInManagedHost returns true if a Host+DPU pair that includes the endpoint has been identified
  rpc IsBmcInManagedHost(BmcEndpointRequest) returns (IsBmcInManagedHostResponse);
  // BmcCredentialStatus returns true if site explorer has the credentials to login to this BMC
  rpc BmcCredentialStatus(BmcEndpointRequest) returns (BmcCredentialStatusResponse);
  // Explore an individual BMC and show the report
  // The results of this exploration call will not be persisted in the database
  rpc Explore(BmcEndpointRequest) returns (site_explorer.EndpointExplorationReport);
  // Prioritizes the exploration of a certain endpoint in the next regular site-explorer run
  // The results of this run will be persisted in the database
  rpc ReExploreEndpoint(ReExploreEndpointRequest) returns (google.protobuf.Empty);
  // Delete an explored endpoint from the database
  rpc DeleteExploredEndpoint(DeleteExploredEndpointRequest) returns (DeleteExploredEndpointResponse);
  // Pause or unpause remediation actions for an explored endpoint
  rpc PauseExploredEndpointRemediation(PauseExploredEndpointRemediationRequest) returns (google.protobuf.Empty);
  // paginated APIs to get site explorer explored endpoints
  rpc FindExploredEndpointIds(site_explorer.ExploredEndpointSearchFilter) returns (site_explorer.ExploredEndpointIdList);
  rpc FindExploredEndpointsByIds(site_explorer.ExploredEndpointsByIdsRequest) returns (site_explorer.ExploredEndpointList);
  // paginated APIs to get site explorer explored managed hosts
  rpc FindExploredManagedHostIds(site_explorer.ExploredManagedHostSearchFilter) returns (site_explorer.ExploredManagedHostIdList);
  rpc FindExploredManagedHostsByIds(site_explorer.ExploredManagedHostsByIdsRequest) returns (site_explorer.ExploredManagedHostList);
  rpc UpdateMachineHardwareInfo(UpdateMachineHardwareInfoRequest) returns (google.protobuf.Empty);

  // Force deletes a Machine and the associated DPU from Forge databases,
  // with the intention of rediscovering the host later on.
  // The command will not stop a running tenant instance. Only a reboot that forces
  // the Forge PXE boot process again would stop the image and run the discovery
  // process again.
  //
  // Due to the not well defined state that hosts are in after calling this command,
  // it should not be used by Tenants or Site Providers to release instances. Those
  // should use customer-facing commands like `ReleaseInstance`.
  //
  // AdminForceDeleteMachine is a lower level admin tool for cases where there is no
  // appropriate customer-facing workflow available or where those workflows fail.
  rpc AdminForceDeleteMachine(AdminForceDeleteMachineRequest) returns (AdminForceDeleteMachineResponse);

  // List existing resource pools and their stats
  rpc AdminListResourcePools(ListResourcePoolsRequest) returns (ResourcePools);

  // Add capacity to a resource pool
  rpc AdminGrowResourcePool(GrowResourcePoolRequest) returns (GrowResourcePoolResponse);

  // Update the Metadata of a Machine
  rpc UpdateMachineMetadata(MachineMetadataUpdateRequest) returns (google.protobuf.Empty);

  // Update the NVLink Info of a Machine
  rpc UpdateMachineNvLinkInfo(UpdateMachineNvLinkInfoRequest) returns (google.protobuf.Empty);

  // Maintenance mode operations: enable, disable
  rpc SetMaintenance(MaintenanceRequest) returns (google.protobuf.Empty);

  // Set a dynamic feature, like RUST_LOG
  rpc SetDynamicConfig(SetDynamicConfigRequest) returns (google.protobuf.Empty);

  // Trigger reprovisioning of DPU
  rpc TriggerDpuReprovisioning(DpuReprovisioningRequest) returns (google.protobuf.Empty);
  // List DPUs waiting for reprovisioning
  rpc ListDpuWaitingForReprovisioning(DpuReprovisioningListRequest) returns (DpuReprovisioningListResponse);

  // Trigger reprovisioning of a host
  rpc TriggerHostReprovisioning(HostReprovisioningRequest) returns (google.protobuf.Empty);
  // List hosts waiting for reprovisioning
  rpc ListHostsWaitingForReprovisioning(HostReprovisioningListRequest) returns (HostReprovisioningListResponse);
  // TODO: Remove when manual upgrade feature is removed
  // Mark host as having completed manual firmware upgrade
  rpc MarkManualFirmwareUpgradeComplete(common.MachineId) returns (google.protobuf.Empty);

  rpc GetDpuInfoList(GetDpuInfoListRequest) returns (GetDpuInfoListResponse);

  rpc GetMachineBootOverride(common.MachineInterfaceId) returns (MachineBootOverride);
  rpc SetMachineBootOverride(MachineBootOverride) returns (google.protobuf.Empty);
  rpc ClearMachineBootOverride(common.MachineInterfaceId) returns (google.protobuf.Empty);

  // Get Network topology
  rpc GetNetworkTopology(NetworkTopologyRequest) returns (NetworkTopologyData);
  rpc FindNetworkDevicesByDeviceIds(NetworkDeviceIdList) returns (NetworkTopologyData);

  // Create Credential in Vault
  rpc CreateCredential(CredentialCreationRequest) returns (CredentialCreationResult);

  // Delete Credential in Vault
  rpc DeleteCredential(CredentialDeletionRequest) returns (CredentialDeletionResult);

  // Route Server Management
  rpc GetRouteServers(google.protobuf.Empty) returns (RouteServerEntries);
  rpc AddRouteServers(RouteServers) returns (google.protobuf.Empty);
  rpc RemoveRouteServers(RouteServers) returns (google.protobuf.Empty);
  rpc ReplaceRouteServers(RouteServers) returns (google.protobuf.Empty);

  // MachineInventory
  rpc UpdateAgentReportedInventory(DpuAgentInventoryReport) returns (google.protobuf.Empty);

  // Phone Home
  rpc UpdateInstancePhoneHomeLastContact(InstancePhoneHomeLastContactRequest) returns (InstancePhoneHomeLastContactResponse);

  // Set Host UEFI password
  rpc SetHostUefiPassword(SetHostUefiPasswordRequest) returns (SetHostUefiPasswordResponse);
  rpc ClearHostUefiPassword(ClearHostUefiPasswordRequest) returns (ClearHostUefiPasswordResponse);

  // Expected Machine Management
  // Add expected machine
  rpc AddExpectedMachine(ExpectedMachine) returns (google.protobuf.Empty);
  // Delete expected machine
  rpc DeleteExpectedMachine(ExpectedMachineRequest) returns (google.protobuf.Empty);
  // Update the BMC credentials for a specific username/password
  rpc UpdateExpectedMachine(ExpectedMachine) returns (google.protobuf.Empty);
  // Get the BMC credentials for a specific expected machine
  rpc GetExpectedMachine(ExpectedMachineRequest) returns (ExpectedMachine);
  // Get the BMC credentials for all expected machines
  rpc GetAllExpectedMachines(google.protobuf.Empty) returns (ExpectedMachineList);

  // Rack Firmware Management
  // Create or update a Rack firmware configuration
  rpc CreateRackFirmware(RackFirmwareCreateRequest) returns (RackFirmware);
  // Get a Rack firmware configuration by ID
  rpc GetRackFirmware(RackFirmwareGetRequest) returns (RackFirmware);
  // List all Rack firmware configurations
  rpc ListRackFirmware(RackFirmwareListRequest) returns (RackFirmwareList);
  // Delete a Rack firmware configuration
  rpc DeleteRackFirmware(RackFirmwareDeleteRequest) returns (google.protobuf.Empty);
  // Apply firmware to all devices in a rack
  rpc ApplyRackFirmware(RackFirmwareApplyRequest) returns (RackFirmwareApplyResponse);

  // Replace all expected machines in site
  rpc ReplaceAllExpectedMachines(ExpectedMachineList) returns (google.protobuf.Empty);
  // Delete all expected machines in site
  rpc DeleteAllExpectedMachines(google.protobuf.Empty) returns (google.protobuf.Empty);
  // Expected machines connected to Explored Endpoints and Machines
  rpc GetAllExpectedMachinesLinked(google.protobuf.Empty) returns (LinkedExpectedMachineList);
  // Batch create expected machines
  rpc CreateExpectedMachines(BatchExpectedMachineOperationRequest) returns (BatchExpectedMachineOperationResponse);
  // Batch update expected machines
  rpc UpdateExpectedMachines(BatchExpectedMachineOperationRequest) returns (BatchExpectedMachineOperationResponse);

  // Expected Power Shelf Management
  // Add expected power shelf
  rpc AddExpectedPowerShelf(ExpectedPowerShelf) returns (google.protobuf.Empty);
  // Delete expected power shelf
  rpc DeleteExpectedPowerShelf(ExpectedPowerShelfRequest) returns (google.protobuf.Empty);
  // Update the BMC credentials for a specific username/password
  rpc UpdateExpectedPowerShelf(ExpectedPowerShelf) returns (google.protobuf.Empty);
  // Get the BMC credentials for a specific expected power shelf
  rpc GetExpectedPowerShelf(ExpectedPowerShelfRequest) returns (ExpectedPowerShelf);
  // Get the BMC credentials for all expected power shelves
  rpc GetAllExpectedPowerShelves(google.protobuf.Empty) returns (ExpectedPowerShelfList);
  // Replace all expected power shelves in site
  rpc ReplaceAllExpectedPowerShelves(ExpectedPowerShelfList) returns (google.protobuf.Empty);
  // Delete all expected power shelves in site
  rpc DeleteAllExpectedPowerShelves(google.protobuf.Empty) returns (google.protobuf.Empty);
  // Expected power shelves connected to Explored Endpoints and Power Shelves
  rpc GetAllExpectedPowerShelvesLinked(google.protobuf.Empty) returns (LinkedExpectedPowerShelfList);

  // Expected Switch Management
  // Add expected switch
  rpc AddExpectedSwitch(ExpectedSwitch) returns (google.protobuf.Empty);
  // Delete expected switch
  rpc DeleteExpectedSwitch(ExpectedSwitchRequest) returns (google.protobuf.Empty);
  // Update the BMC credentials for a specific username/password
  rpc UpdateExpectedSwitch(ExpectedSwitch) returns (google.protobuf.Empty);
  // Get the BMC credentials for a specific expected switch
  rpc GetExpectedSwitch(ExpectedSwitchRequest) returns (ExpectedSwitch);
  // Get the BMC credentials for all expected switches
  rpc GetAllExpectedSwitches(google.protobuf.Empty) returns (ExpectedSwitchList);
  // Replace all expected switches in site
  rpc ReplaceAllExpectedSwitches(ExpectedSwitchList) returns (google.protobuf.Empty);
  // Delete all expected switches in site
  rpc DeleteAllExpectedSwitches(google.protobuf.Empty) returns (google.protobuf.Empty);
  // Expected switches connected to Explored Endpoints and switches
  rpc GetAllExpectedSwitchesLinked(google.protobuf.Empty) returns (LinkedExpectedSwitchList);

  // Perform Attestation Procedure for Measured Boot
  rpc AttestQuote	(AttestQuoteRequest) returns (AttestQuoteResponse);

  //
  // InstanceType
  //
  rpc CreateInstanceType(CreateInstanceTypeRequest) returns (CreateInstanceTypeResponse);
  rpc FindInstanceTypeIds(FindInstanceTypeIdsRequest) returns (FindInstanceTypeIdsResponse);
  rpc FindInstanceTypesByIds(FindInstanceTypesByIdsRequest) returns (FindInstanceTypesByIdsResponse);
  rpc UpdateInstanceType(UpdateInstanceTypeRequest) returns (UpdateInstanceTypeResponse);
  rpc DeleteInstanceType(DeleteInstanceTypeRequest) returns (DeleteInstanceTypeResponse);
  rpc AssociateMachinesWithInstanceType(AssociateMachinesWithInstanceTypeRequest) returns (AssociateMachinesWithInstanceTypeResponse);
  rpc RemoveMachineInstanceTypeAssociation(RemoveMachineInstanceTypeAssociationRequest) returns (RemoveMachineInstanceTypeAssociationResponse);

  ////////////////////////////////////////////////////////////////////////////////
  // Begin Measured Boot API Endpoints
  ////////////////////////////////////////////////////////////////////////////////

  // Measured Boot: Bundles
  rpc CreateMeasurementBundle(measured_boot.CreateMeasurementBundleRequest) returns (measured_boot.CreateMeasurementBundleResponse);
  rpc DeleteMeasurementBundle(measured_boot.DeleteMeasurementBundleRequest) returns (measured_boot.DeleteMeasurementBundleResponse);
  rpc RenameMeasurementBundle(measured_boot.RenameMeasurementBundleRequest) returns (measured_boot.RenameMeasurementBundleResponse);
  rpc UpdateMeasurementBundle(measured_boot.UpdateMeasurementBundleRequest) returns (measured_boot.UpdateMeasurementBundleResponse);
  rpc ShowMeasurementBundle(measured_boot.ShowMeasurementBundleRequest) returns (measured_boot.ShowMeasurementBundleResponse);
  rpc ShowMeasurementBundles(measured_boot.ShowMeasurementBundlesRequest) returns (measured_boot.ShowMeasurementBundlesResponse);
  rpc ListMeasurementBundles(measured_boot.ListMeasurementBundlesRequest) returns (measured_boot.ListMeasurementBundlesResponse);
  rpc ListMeasurementBundleMachines(measured_boot.ListMeasurementBundleMachinesRequest) returns (measured_boot.ListMeasurementBundleMachinesResponse);
  rpc FindClosestBundleMatch(measured_boot.FindClosestBundleMatchRequest) returns (measured_boot.ShowMeasurementBundleResponse);


  // Measured Boot: Journals
  rpc DeleteMeasurementJournal(measured_boot.DeleteMeasurementJournalRequest) returns (measured_boot.DeleteMeasurementJournalResponse);
  rpc ShowMeasurementJournal(measured_boot.ShowMeasurementJournalRequest) returns (measured_boot.ShowMeasurementJournalResponse);
  rpc ShowMeasurementJournals(measured_boot.ShowMeasurementJournalsRequest) returns (measured_boot.ShowMeasurementJournalsResponse);
  rpc ListMeasurementJournal(measured_boot.ListMeasurementJournalRequest) returns (measured_boot.ListMeasurementJournalResponse);

  // Measured Boot: Machines
  rpc AttestCandidateMachine(measured_boot.AttestCandidateMachineRequest) returns (measured_boot.AttestCandidateMachineResponse);
  rpc ShowCandidateMachine(measured_boot.ShowCandidateMachineRequest) returns (measured_boot.ShowCandidateMachineResponse);
  rpc ShowCandidateMachines(measured_boot.ShowCandidateMachinesRequest) returns (measured_boot.ShowCandidateMachinesResponse);
  rpc ListCandidateMachines(measured_boot.ListCandidateMachinesRequest) returns (measured_boot.ListCandidateMachinesResponse);

  // Measured Boot: Profiles
  rpc CreateMeasurementSystemProfile(measured_boot.CreateMeasurementSystemProfileRequest) returns (measured_boot.CreateMeasurementSystemProfileResponse);
  rpc DeleteMeasurementSystemProfile(measured_boot.DeleteMeasurementSystemProfileRequest) returns (measured_boot.DeleteMeasurementSystemProfileResponse);
  rpc RenameMeasurementSystemProfile(measured_boot.RenameMeasurementSystemProfileRequest) returns (measured_boot.RenameMeasurementSystemProfileResponse);
  rpc ShowMeasurementSystemProfile(measured_boot.ShowMeasurementSystemProfileRequest) returns (measured_boot.ShowMeasurementSystemProfileResponse);
  rpc ShowMeasurementSystemProfiles(measured_boot.ShowMeasurementSystemProfilesRequest) returns (measured_boot.ShowMeasurementSystemProfilesResponse);
  rpc ListMeasurementSystemProfiles(measured_boot.ListMeasurementSystemProfilesRequest) returns (measured_boot.ListMeasurementSystemProfilesResponse);
  rpc ListMeasurementSystemProfileBundles(measured_boot.ListMeasurementSystemProfileBundlesRequest) returns (measured_boot.ListMeasurementSystemProfileBundlesResponse);
  rpc ListMeasurementSystemProfileMachines(measured_boot.ListMeasurementSystemProfileMachinesRequest) returns (measured_boot.ListMeasurementSystemProfileMachinesResponse);

  // Measured Boot: Reports
  rpc CreateMeasurementReport(measured_boot.CreateMeasurementReportRequest) returns (measured_boot.CreateMeasurementReportResponse);
  rpc DeleteMeasurementReport(measured_boot.DeleteMeasurementReportRequest) returns (measured_boot.DeleteMeasurementReportResponse);
  rpc PromoteMeasurementReport(measured_boot.PromoteMeasurementReportRequest) returns (measured_boot.PromoteMeasurementReportResponse);
  rpc RevokeMeasurementReport(measured_boot.RevokeMeasurementReportRequest) returns (measured_boot.RevokeMeasurementReportResponse);
  rpc ShowMeasurementReportForId(measured_boot.ShowMeasurementReportForIdRequest) returns (measured_boot.ShowMeasurementReportForIdResponse);
  rpc ShowMeasurementReportsForMachine(measured_boot.ShowMeasurementReportsForMachineRequest) returns (measured_boot.ShowMeasurementReportsForMachineResponse);
  rpc ShowMeasurementReports(measured_boot.ShowMeasurementReportsRequest) returns (measured_boot.ShowMeasurementReportsResponse);
  rpc ListMeasurementReport(measured_boot.ListMeasurementReportRequest) returns (measured_boot.ListMeasurementReportResponse);
  rpc MatchMeasurementReport(measured_boot.MatchMeasurementReportRequest) returns (measured_boot.MatchMeasurementReportResponse);

  // Measured Boot: Site
  rpc ImportSiteMeasurements(measured_boot.ImportSiteMeasurementsRequest) returns (measured_boot.ImportSiteMeasurementsResponse);
  rpc ExportSiteMeasurements(measured_boot.ExportSiteMeasurementsRequest) returns (measured_boot.ExportSiteMeasurementsResponse);
  rpc AddMeasurementTrustedMachine(measured_boot.AddMeasurementTrustedMachineRequest) returns (measured_boot.AddMeasurementTrustedMachineResponse);
  rpc RemoveMeasurementTrustedMachine(measured_boot.RemoveMeasurementTrustedMachineRequest) returns (measured_boot.RemoveMeasurementTrustedMachineResponse);
  rpc AddMeasurementTrustedProfile(measured_boot.AddMeasurementTrustedProfileRequest) returns (measured_boot.AddMeasurementTrustedProfileResponse);
  rpc RemoveMeasurementTrustedProfile(measured_boot.RemoveMeasurementTrustedProfileRequest) returns (measured_boot.RemoveMeasurementTrustedProfileResponse);
  rpc ListMeasurementTrustedMachines(measured_boot.ListMeasurementTrustedMachinesRequest) returns (measured_boot.ListMeasurementTrustedMachinesResponse);
  rpc ListMeasurementTrustedProfiles(measured_boot.ListMeasurementTrustedProfilesRequest) returns (measured_boot.ListMeasurementTrustedProfilesResponse);
  rpc ListAttestationSummary(measured_boot.ListAttestationSummaryRequest) returns (measured_boot.ListAttestationSummaryResponse);

  ////////////////////////////////////////////////////////////////////////////////
  // End Measured Boot API Endpoints
  ////////////////////////////////////////////////////////////////////////////////

  //
  // NetworkSecurityGroups
  //
  rpc CreateNetworkSecurityGroup(CreateNetworkSecurityGroupRequest) returns (CreateNetworkSecurityGroupResponse);
  rpc FindNetworkSecurityGroupIds(FindNetworkSecurityGroupIdsRequest) returns (FindNetworkSecurityGroupIdsResponse);
  rpc FindNetworkSecurityGroupsByIds(FindNetworkSecurityGroupsByIdsRequest) returns (FindNetworkSecurityGroupsByIdsResponse);
  rpc UpdateNetworkSecurityGroup(UpdateNetworkSecurityGroupRequest) returns (UpdateNetworkSecurityGroupResponse);
  rpc DeleteNetworkSecurityGroup(DeleteNetworkSecurityGroupRequest) returns (DeleteNetworkSecurityGroupResponse);
  rpc GetNetworkSecurityGroupPropagationStatus(GetNetworkSecurityGroupPropagationStatusRequest) returns (GetNetworkSecurityGroupPropagationStatusResponse);
  rpc GetNetworkSecurityGroupAttachments(GetNetworkSecurityGroupAttachmentsRequest) returns (GetNetworkSecurityGroupAttachmentsResponse);


  rpc CreateOsImage(OsImageAttributes) returns (OsImage);
  rpc DeleteOsImage(DeleteOsImageRequest) returns (DeleteOsImageResponse);
  rpc ListOsImage(ListOsImageRequest) returns (ListOsImageResponse);
  rpc GetOsImage(common.UUID) returns (OsImage);
  rpc UpdateOsImage(OsImageAttributes) returns (OsImage);

  rpc RebootCompleted(MachineRebootCompletedRequest) returns (MachineRebootCompletedResponse);

  // Validation result Persist
  rpc PersistValidationResult(MachineValidationResultPostRequest) returns (google.protobuf.Empty);

  // Machine-Validation result list
  rpc GetMachineValidationResults(MachineValidationGetRequest) returns (MachineValidationResultList);

  // Machine-Validation completed
  rpc MachineValidationCompleted(MachineValidationCompletedRequest) returns (MachineValidationCompletedResponse);

  rpc MachineSetAutoUpdate(MachineSetAutoUpdateRequest) returns (MachineSetAutoUpdateResponse);

  // Machine-Validation ExternalConfig Config
  // Depricate this later
  rpc GetMachineValidationExternalConfig(GetMachineValidationExternalConfigRequest) returns (GetMachineValidationExternalConfigResponse);

  // Machine-Validation ExternalConfig Configs
  rpc GetMachineValidationExternalConfigs(GetMachineValidationExternalConfigsRequest) returns (GetMachineValidationExternalConfigsResponse);

  // post or put Machine-Validation ExternalConfig Config
  rpc AddUpdateMachineValidationExternalConfig(AddUpdateMachineValidationExternalConfigRequest) returns (google.protobuf.Empty);
  // Machine-Validation executed list
  rpc GetMachineValidationRuns(MachineValidationRunListGetRequest) returns (MachineValidationRunList);

  // Remove ExternalConfig
  rpc RemoveMachineValidationExternalConfig(RemoveMachineValidationExternalConfigRequest) returns (google.protobuf.Empty);
  // Machine-Validation test list
  rpc GetMachineValidationTests(MachineValidationTestsGetRequest) returns (MachineValidationTestsGetResponse);

  rpc AddMachineValidationTest(MachineValidationTestAddRequest) returns (MachineValidationTestAddUpdateResponse);

  rpc UpdateMachineValidationTest(MachineValidationTestUpdateRequest) returns (MachineValidationTestAddUpdateResponse);

  rpc MachineValidationTestVerfied(MachineValidationTestVerfiedRequest) returns (MachineValidationTestVerfiedResponse);

  rpc MachineValidationTestNextVersion(MachineValidationTestNextVersionRequest) returns (MachineValidationTestNextVersionResponse);

  rpc MachineValidationTestEnableDisableTest(MachineValidationTestEnableDisableTestRequest) returns (MachineValidationTestEnableDisableTestResponse);

  rpc UpdateMachineValidationRun(MachineValidationRunRequest) returns (MachineValidationRunResponse);

  // Bmc Endpoint Explorer Actions
  // Reset a BMC
  rpc AdminBmcReset(AdminBmcResetRequest) returns (AdminBmcResetResponse);
  // Admin Power Control
  rpc AdminPowerControl(AdminPowerControlRequest) returns (AdminPowerControlResponse);
  // Disable Secure Boot
  rpc DisableSecureBoot(BmcEndpointRequest) returns (DisableSecureBootResponse);
  // Set Lockdown (Enable or Disable)
  rpc Lockdown(LockdownRequest) returns (LockdownResponse);
  // Fetch Lockdown Status
  rpc LockdownStatus(LockdownStatusRequest) returns (site_explorer.LockdownStatus);
  // Start Machine Setup
  rpc MachineSetup(MachineSetupRequest) returns (MachineSetupResponse);
  // Set DPU as first boot option
  rpc SetDpuFirstBootOrder(SetDpuFirstBootOrderRequest) returns (SetDpuFirstBootOrderResponse);
  // Create BMC User
  rpc CreateBmcUser(CreateBmcUserRequest) returns (CreateBmcUserResponse);
  // Delete BMC User
  rpc DeleteBmcUser(DeleteBmcUserRequest) returns (DeleteBmcUserResponse);
  // Enable Infinite Boot
  rpc EnableInfiniteBoot(EnableInfiniteBootRequest) returns (EnableInfiniteBootResponse);
  // Check Infinite Boot Status
  rpc IsInfiniteBootEnabled(IsInfiniteBootEnabledRequest) returns (IsInfiniteBootEnabledResponse);

  // On demand Machine-Validation
  rpc OnDemandMachineValidation(MachineValidationOnDemandRequest) returns (MachineValidationOnDemandResponse);

  // TPM CA certs Management
  //rpc TpmDeleteCaCert(TpmCaCertDetails) returns (google.protobuf.Empty);
  rpc TpmAddCaCert(TpmCaCert) returns (TpmCaAddedCaStatus);
  rpc TpmShowCaCerts(google.protobuf.Empty) returns (TpmCaCertDetailCollection);
  rpc TpmShowUnmatchedEkCerts(google.protobuf.Empty) returns (TpmEkCertStatusCollection);
  rpc TpmDeleteCaCert(TpmCaCertId) returns (google.protobuf.Empty);

  rpc RedfishBrowse(RedfishBrowseRequest) returns (RedfishBrowseResponse);
  rpc RedfishListActions(RedfishListActionsRequest) returns (RedfishListActionsResponse);
  rpc RedfishCreateAction(RedfishCreateActionRequest) returns (RedfishCreateActionResponse);
  rpc RedfishApproveAction(RedfishActionID) returns (RedfishApproveActionResponse);
  rpc RedfishApplyAction(RedfishActionID) returns (RedfishApplyActionResponse);
  rpc RedfishCancelAction(RedfishActionID) returns (RedfishCancelActionResponse);

  rpc UfmBrowse(UfmBrowseRequest) returns (UfmBrowseResponse);

  rpc GetDesiredFirmwareVersions(GetDesiredFirmwareVersionsRequest) returns (GetDesiredFirmwareVersionsResponse);

  // Create A SKU to be assigned to a machine so the machine hardware can be validated.
  rpc CreateSku(SkuList) returns (SkuIdList);
  // Generate a SKU from the hardware inventory of a machine.
  rpc GenerateSkuFromMachine(common.MachineId) returns (Sku);
  // Verify the specified machine against its sku.  Must be in Ready or SkuVerifyFailed states.
  rpc VerifySkuForMachine(common.MachineId) returns (google.protobuf.Empty);
  // Assing a sku to a machine.  The machine must not have a sku assigned already.
  rpc AssignSkuToMachine(SkuMachinePair) returns (google.protobuf.Empty);
  // Remove a SKU assignemnt from a machine.  Must be in the Ready or SkuVerifyFailed states.
  // The machine will move to the WaitingForSkuAssignment state.
  rpc RemoveSkuAssociation(RemoveSkuRequest) returns (google.protobuf.Empty);
  // Removes an unused SKU
  rpc DeleteSku(SkuIdList) returns (google.protobuf.Empty);
  rpc GetAllSkuIds(google.protobuf.Empty) returns (SkuIdList);
  rpc FindSkusByIds(SkusByIdsRequest) returns (SkuList);
  rpc UpdateSkuMetadata(SkuUpdateMetadataRequest) returns (google.protobuf.Empty);
  rpc ReplaceSku(Sku) returns (Sku);

  // get/set/clear quarantine state on machines
  rpc GetManagedHostQuarantineState(GetManagedHostQuarantineStateRequest) returns (GetManagedHostQuarantineStateResponse);
  rpc SetManagedHostQuarantineState(SetManagedHostQuarantineStateRequest) returns (SetManagedHostQuarantineStateResponse);
  rpc ClearManagedHostQuarantineState(ClearManagedHostQuarantineStateRequest) returns (ClearManagedHostQuarantineStateResponse);

  rpc ResetHostReprovisioning(common.MachineId) returns (google.protobuf.Empty);
  // Copy BFB to DPU's RSHIM
  rpc CopyBfbToDpuRshim(CopyBfbToDpuRshimRequest) returns (google.protobuf.Empty);

  // Spectrum-X East West Networking related calls
  rpc GetAllDpaInterfaceIds(google.protobuf.Empty) returns (DpaInterfaceIdList);
  rpc FindDpaInterfacesByIds(DpaInterfacesByIdsRequest) returns (DpaInterfaceList);
  // XXX TODO XXX Remove the calls below, as they are only for debug testing
  rpc CreateDpaInterface(DpaInterfaceCreationRequest) returns (DpaInterface);
  rpc DeleteDpaInterface(DpaInterfaceDeletionRequest) returns (DpaInterfaceDeletionResult);
  rpc SetDpaNetworkObservationStatus(DpaNetworkObservationSetRequest) returns (DpaInterface);

  // Power Options
  rpc GetPowerOptions(PowerOptionRequest) returns (PowerOptionResponse);
  rpc UpdatePowerOption(PowerOptionUpdateRequest) returns (PowerOptionResponse);
  rpc AllowIngestionAndPowerOn(BmcEndpointRequest) returns (google.protobuf.Empty);
  rpc DetermineMachineIngestionState(BmcEndpointRequest) returns (MachineIngestionStateResponse);

  // Rack
  rpc GetRack(GetRackRequest) returns (GetRackResponse);
  rpc DeleteRack(DeleteRackRequest) returns (google.protobuf.Empty);

  rpc SetFirmwareUpdateTimeWindow(SetFirmwareUpdateTimeWindowRequest) returns (SetFirmwareUpdateTimeWindowResponse);
  rpc ListHostFirmware(ListHostFirmwareRequest) returns (ListHostFirmwareResponse);
  rpc PublishMlxDeviceReport(mlx_device.PublishMlxDeviceReportRequest) returns (mlx_device.PublishMlxDeviceReportResponse);
  rpc PublishMlxObservationReport(mlx_device.PublishMlxObservationReportRequest) returns (mlx_device.PublishMlxObservationReportResponse);

  // Trim DB Tables
  rpc TrimTable(TrimTableRequest) returns (TrimTableResponse);

  // begin DPU Remediation APIs
  // these apis are intended for consumption by the admin-cli to manage remediations and their status
  rpc CreateRemediation(CreateRemediationRequest) returns (CreateRemediationResponse);

  rpc ApproveRemediation(ApproveRemediationRequest) returns (google.protobuf.Empty);
  // the revoke call will also disable the remediation.
  rpc RevokeRemediation(RevokeRemediationRequest) returns (google.protobuf.Empty);

  rpc EnableRemediation(EnableRemediationRequest) returns (google.protobuf.Empty);
  rpc DisableRemediation(DisableRemediationRequest) returns (google.protobuf.Empty);

  rpc FindRemediationIds(google.protobuf.Empty) returns (RemediationIdList);
  rpc FindRemediationsByIds(RemediationIdList) returns (RemediationList);

  rpc FindAppliedRemediationIds(FindAppliedRemediationIdsRequest) returns (AppliedRemediationIdList);
  rpc FindAppliedRemediations(FindAppliedRemediationsRequest) returns (AppliedRemediationList);

  // these two are called by the DPU agent to fetch the next script and to report the status of the one just applied
  rpc GetNextRemediationForMachine(GetNextRemediationForMachineRequest) returns (GetNextRemediationForMachineResponse);
  rpc RemediationApplied(RemediationAppliedRequest) returns (google.protobuf.Empty);
  // end DPU Remediation APIs

  rpc SetPrimaryDpu(SetPrimaryDpuRequest) returns (google.protobuf.Empty);

  // Extension service version management
  rpc CreateDpuExtensionService(CreateDpuExtensionServiceRequest) returns (DpuExtensionService);
  rpc UpdateDpuExtensionService(UpdateDpuExtensionServiceRequest) returns (DpuExtensionService);
  rpc DeleteDpuExtensionService(DeleteDpuExtensionServiceRequest) returns (DeleteDpuExtensionServiceResponse);

  rpc FindDpuExtensionServiceIds(DpuExtensionServiceSearchFilter) returns (DpuExtensionServiceIdList);
  rpc FindDpuExtensionServicesByIds(DpuExtensionServicesByIdsRequest) returns (DpuExtensionServiceList);
  rpc GetDpuExtensionServiceVersionsInfo(GetDpuExtensionServiceVersionsInfoRequest) returns (DpuExtensionServiceVersionInfoList);
  rpc FindInstancesByDpuExtensionService(FindInstancesByDpuExtensionServiceRequest) returns (FindInstancesByDpuExtensionServiceResponse);

  // SPDM attestation APIs start
  rpc TriggerMachineAttestation(AttestationData) returns (google.protobuf.Empty);
  rpc CancelMachineAttestation(AttestationData) returns (google.protobuf.Empty);
  rpc FindMachineIdsUnderAttestation(AttestationIdsRequest) returns (common.MachineIdList);
  rpc FindMachinesUnderAttestation(AttestationMachineList) returns (AttestationResponse);
  // SPDM attestation APIs end

  // ScoutStream establishes a bidirectional streaming connection between
  // scout agents and carbide-api. The initial use-case for this is for
  // Mellanox device management using forge-admin-cli, but there's an
  // opportunity to pull the ForgeAgentControl flow into here as well.
  rpc ScoutStream(stream ScoutStreamApiBoundMessage) returns (stream ScoutStreamScoutBoundMessage);

  // ScoutStreamShowConnections is used to show all established
  // connections from scout agents to the ScoutStream endpoint.
  rpc ScoutStreamShowConnections(ScoutStreamShowConnectionsRequest) returns (ScoutStreamShowConnectionsResponse);

  // ScoutStreamDisconnect is used to disconnect a current machines
  // ScoutStream connection.
  rpc ScoutStreamDisconnect(ScoutStreamDisconnectRequest) returns (ScoutStreamDisconnectResponse);

  // ScoutStreamPing is used to ping a given machine ID's scout stream
  // connection to make sure it's responsive.
  rpc ScoutStreamPing(ScoutStreamAdminPingRequest) returns (ScoutStreamAdminPingResponse);

  // Mellanox administrative endpoints for profile management, which are called by
  // the CLI (forge-admin-cli) and potentially the UI. These endpoints ultimately
  // interconnect with a scout agent listening via an open ScoutStream connection.
  //
  // MlxAdminProfileSync is used to sync an MlxConfigProfile to a given device.
  rpc MlxAdminProfileSync(mlx_device.MlxAdminProfileSyncRequest) returns (mlx_device.MlxAdminProfileSyncResponse);
  // MlxAdminProfileShow shows the configuration of a specific MlxConfigProfile
  // loaded into carbide-api.
  rpc MlxAdminProfileShow(mlx_device.MlxAdminProfileShowRequest) returns (mlx_device.MlxAdminProfileShowResponse);
  // MlxAdminProfileCompare compares the running config of a device to
  // the values of a given MlxConfigProfile.
  rpc MlxAdminProfileCompare(mlx_device.MlxAdminProfileCompareRequest) returns (mlx_device.MlxAdminProfileCompareResponse);
  // MlxAdminProfileList lists all configured MlxConfigProfiles in carbide-api.
  rpc MlxAdminProfileList(mlx_device.MlxAdminProfileListRequest) returns (mlx_device.MlxAdminProfileListResponse);

  // Mellanox administrative endpoints for lockdown management, which are called by
  // the CLI (forge-admin-cli) and potentially the UI. These endpoints ultimately
  // interconnect with a scout agent listening via an open ScoutStream connection.
  //
  // MlxAdminLockdownLock locks a Mellanox device, using whatever key is currently
  // managed internally within Carbide.
  rpc MlxAdminLockdownLock(mlx_device.MlxAdminLockdownLockRequest) returns (mlx_device.MlxAdminLockdownLockResponse);
  // MlxAdminLockdownUnlock unlocks a Mellanox device, using whatever key is currently
  // managed internally within Carbide.
  rpc MlxAdminLockdownUnlock(mlx_device.MlxAdminLockdownUnlockRequest) returns (mlx_device.MlxAdminLockdownUnlockResponse);
  // MlxAdminLockdownStatus returns the live lock status of a Mellanox device
  // by querying over an open ScoutStream connection.
  rpc MlxAdminLockdownStatus(mlx_device.MlxAdminLockdownStatusRequest) returns (mlx_device.MlxAdminLockdownStatusResponse);

  // Mellanox administrative endpoints for device info querying, which are called by
  // the CLI (forge-admin-cli) and potentially the UI. These endpoints ultimately
  // interconnect with a scout agent listening via an open ScoutStream connection.
  //
  // MlxAdminShowDevice will show MlxDeviceInfo data for a given device on a machine.
  rpc MlxAdminShowDevice(mlx_device.MlxAdminDeviceInfoRequest) returns (mlx_device.MlxAdminDeviceInfoResponse);
  // MlxAdminShowMachine will show an MlxDeviceReport for a given machine.
  rpc MlxAdminShowMachine(mlx_device.MlxAdminDeviceReportRequest) returns (mlx_device.MlxAdminDeviceReportResponse);

  // Mellanox administrative endpoints for registry querying, which are called by
  // the CLI (forge-admin-cli) and potentially the UI. These endpoints ultimately
  // interconnect with a scout agent listening via an open ScoutStream connection.
  //
  // MlxAdminRegistryList lists all known mlxconfig variable registries
  // that are currently compiled into scout on the target machine.
  rpc MlxAdminRegistryList(mlx_device.MlxAdminRegistryListRequest) returns (mlx_device.MlxAdminRegistryListResponse);
  // MlxAdminRegistryShow returns the given MlxVariableRegistry as
  // configured on the scout agent on the target machine.
  rpc MlxAdminRegistryShow(mlx_device.MlxAdminRegistryShowRequest) returns (mlx_device.MlxAdminRegistryShowResponse);

  // Mellanox administrative endpoints for direct mlxconfig management, called by
  // the CLI (forge-admin-cli) and potentially the UI. These endpoints ultimately
  // interconnect with a scout agent listening via an open ScoutStream connection.
  //
  // MlxAdminConfigQuery is used to fetch one or more running mlxconfig
  // variable values for the provided target machine device.
  rpc MlxAdminConfigQuery(mlx_device.MlxAdminConfigQueryRequest) returns (mlx_device.MlxAdminConfigQueryResponse);
  // MlxAdminConfigSet is used to set one or more running mlxconfig
  // variable values for the provided target machine device.
  rpc MlxAdminConfigSet(mlx_device.MlxAdminConfigSetRequest) returns (mlx_device.MlxAdminConfigSetResponse);
  // MlxAdminConfigSync is used to sync one or more running mlxconfig
  // variable values for the provided target machine device, reporting back
  // specifics of what changed.
  rpc MlxAdminConfigSync(mlx_device.MlxAdminConfigSyncRequest) returns (mlx_device.MlxAdminConfigSyncResponse);
  // MlxAdminConfigSync is used to compare one or more running mlxconfig
  // variable values for the provided target machine device, reporting back
  // specifics of what would change.
  rpc MlxAdminConfigCompare(mlx_device.MlxAdminConfigCompareRequest) returns (mlx_device.MlxAdminConfigCompareResponse);

  // NVL Partition
  rpc FindNVLinkPartitionIds(NVLinkPartitionSearchFilter) returns (NVLinkPartitionIdList);
  rpc FindNVLinkPartitionsByIds(NVLinkPartitionsByIdsRequest) returns (NVLinkPartitionList);
  // Find all NVLink partitions under a specified tenant
  rpc NVLinkPartitionsForTenant(TenantSearchQuery) returns (NVLinkPartitionList);

  // NVL Logical Partitions
  rpc FindNVLinkLogicalPartitionIds(NVLinkLogicalPartitionSearchFilter) returns (NVLinkLogicalPartitionIdList);
  rpc FindNVLinkLogicalPartitionsByIds(NVLinkLogicalPartitionsByIdsRequest) returns (NVLinkLogicalPartitionList);
  // Create a Logical partition
  rpc CreateNVLinkLogicalPartition(NVLinkLogicalPartitionCreationRequest) returns (NVLinkLogicalPartition);
  // Update a Logical partition
  rpc UpdateNVLinkLogicalPartition(NVLinkLogicalPartitionUpdateRequest) returns (NVLinkLogicalPartitionUpdateResult);
  // Delete a Logical partition
  rpc DeleteNVLinkLogicalPartition(NVLinkLogicalPartitionDeletionRequest) returns (NVLinkLogicalPartitionDeletionResult);
  // Find all Logical partitions under a specified tenant
  rpc NVLinkLogicalPartitionsForTenant(TenantSearchQuery) returns (NVLinkLogicalPartitionList);
  // Get position related information for machines
  rpc GetMachinePositionInfo(MachinePositionQuery) returns (MachinePositionInfoList);

  rpc NmxmBrowse(NmxmBrowseRequest) returns (NmxmBrowseResponse);

  rpc ModifyDPFState(ModifyDPFStateRequest) returns (google.protobuf.Empty);
  rpc GetDPFState(GetDPFStateRequest) returns (DPFStateResponse);
}

message AttestationIdsRequest {

}

message AttestationData {
  common.MachineId machine_id = 1;
}

message AttestationMachineList {
  repeated common.MachineId machine_ids = 1;
}

message AttestationResponse {
  message AttestationDeviceData {
    string device_id = 1;
    common.UUID nonce = 2;
    string state = 3;
    optional string metadata = 4;
  }
  message AttestationMachineData {
    common.MachineId machine_id = 1;
    google.protobuf.Timestamp requested_at = 2;
    optional google.protobuf.Timestamp started_at = 3;
    optional google.protobuf.Timestamp canceled_at = 4;
    string state = 5;
    string state_version = 6;
    optional string state_outcome = 7;
    string status = 8;
    repeated AttestationDeviceData device_data = 9;
  }
  repeated AttestationMachineData machines = 1;
}

// Determines machine ingestion state in relation to the power on gate
// NotDiscovered - the machine has not been discovered.
// WaitingForIngestion - the machine is stuck at the gate, will not be powered on yet.
// IngestionMachineCreated - the machine is past the gate and has been ingested.
// IngestionMachineNotCreated - the machine is past the gate, but the entry
// in the DB hasn't been created yet.
enum MachineIngestionState {
  NotDiscovered = 0;
  WaitingForIngestion = 1;
  IngestionMachineNotCreated = 2;
  IngestionMachineCreated = 3;
}

message MachineIngestionStateResponse{
  MachineIngestionState machine_ingestion_state = 1;
}

message TpmCaAddedCaStatus{
  TpmCaCertId id = 1;
  int32 matched_ek_certs = 2;
}

message TpmCaCertId{
  int32 ca_cert_id = 1;
}

message TpmEkCertStatus{
  string serial_num = 1;
  common.MachineId machine_id = 2;
  string issuer = 3;
  optional string issuer_ca_url = 4;
}

message TpmEkCertStatusCollection{
  repeated TpmEkCertStatus tpm_ek_cert_statuses = 1;
}

message TpmCaCert{
  // TPM's CA cert in DER encoding
  bytes ca_cert = 1;
}

message TpmCaCertDetail{
  int32 ca_cert_id = 1;
  string not_valid_before = 2;
  string not_valid_after = 3;
  string ca_cert_subject = 4;
}

message TpmCaCertDetailCollection{
  repeated TpmCaCertDetail tpm_ca_cert_details = 1;
}

message AttestKeyBindChallenge{
  // Encrypted Credential (kind of AuthToken)
  bytes cred_blob = 1;
  // Encrypted Seed (used to generate key to decrypt CredBlob)
  bytes encrypted_secret = 2;
}

message AttestQuoteRequest{
  common.MachineId machine_id = 1;
  // Kind of AuthToken
  bytes credential = 2;
  // TPM generated Attestation struct, contains a hash of PcrValues
  bytes attestation = 3;
  // Signature of Attenstation
  bytes signature = 4;
  // Actual PCR Values (from which Attestation is computed)
  repeated bytes pcr_values = 5;
  // Event Log generated by TPM
  optional bytes event_log = 6;
}

message AttestQuoteResponse{
  bool success = 1;
  MachineCertificate machine_certificate = 2;
}

enum CredentialType {
  HostBMC = 0;
  DPUBMC = 1;
  UFM = 2;
  DpuUefi = 3;
  HostUefi = 4;
  HostBMCFactoryDefault = 5;
  DpuBMCFactoryDefault = 6;
  SiteWideBmcRoot = 7;
  RootBmcByMacAddress = 8;
  BmcForgeAdminByMacAddress = 9;
  NmxM = 10;
}

message CredentialCreationRequest {
  // Credential type
  CredentialType credential_type = 1;
  // The username of credential.
  // No need specify it for HostBMC, DPUBMC, DpuUefi.
  // For UFM, the username is the URL of UFM.
  optional string username = 2;
  // The password of credential for HostBMC, DPUBMC, DpuUefi.
  // For UFM, the password is the token of UFM.
  string password = 3;
  // For the BMC factory default credential: "dell", "lenovo", "hpe", "supermicro", etc
  optional string vendor = 4;
  optional string mac_address = 5;
}

message CredentialDeletionRequest {
  CredentialType credential_type = 1;
  optional string username = 2;
  optional string mac_address = 3;
}

message CredentialCreationResult {

}

message CredentialDeletionResult {

}

message VersionRequest {
  bool display_config = 1;
}

message BuildInfo {
  string build_version = 1; // v2023.06-rc2-1-gc5c05de3
  string build_date = 2; // 2023-06-05
  string git_sha = 3; // c5c05de3
  string rust_version = 4; // rustc 1.68.0 (2c8cc3432 2023-03-06)
  string build_user = 5; // graham
  string build_hostname = 6; // fedora

  optional RuntimeConfig runtime_config = 50;
}

message RuntimeConfig {
  string listen = 1;
  string metrics_endpoint = 2;
  reserved 3; // Was: string otlp_endpoint
  string database_url = 4;
  bool enable_ip_fabric = 5;
  reserved 6; // deprecated rapid_iterations
  uint32 asn = 7;
  repeated string dhcp_servers = 8;
  repeated string route_servers = 9;
  bool enable_route_servers = 10;
  repeated string deny_prefixes = 11;
  repeated string site_fabric_prefixes = 12;

  // Only name. Rest config can be read from network-segment command.
  repeated string networks = 13;

  reserved 14;  // deprecated dpu_ipmi_reboot_args

  string dpu_ipmi_tool_impl = 15;
  uint32 dpu_ipmi_reboot_attempt = 16;

  optional string initial_domain_name = 17;
  string initial_dpu_agent_upgrade_policy = 18;

  map<string, string> dpu_nic_firmware_update_version = 19;
  bool dpu_nic_firmware_initial_update_enabled = 20;
  bool dpu_nic_firmware_reprovision_update_enabled = 21;
  int32 max_concurrent_machine_updates = 22;
  uint64 machine_update_runtime_interval = 23;

  reserved 24;
  bool nvue_enabled = 25;
  uint32 max_database_connections = 26;

  bool auto_host_firmware_update = 27;
  repeated string host_enable_autoupdate = 28;
  repeated string host_disable_autoupdate = 29;

  uint32 max_find_by_ids = 30;
  bool attestation_enabled = 31;

  optional string dpu_network_pinger_type = 32;
  bool machine_validation_enabled = 33;

  string vpc_isolation_behavior = 34;

  // BOM Validation Configuration
  bool bom_validation_enabled = 35;
  bool bom_validation_ignore_unassigned_machines = 36; // TODO: Remove after all consumers updated

  repeated string dpu_nic_firmware_update_versions=37;

  bool dpa_enabled = 38;
  string mqtt_endpoint = 39;

  optional string sitename = 40;

  bool bom_validation_auto_generate_missing_sku = 41;
  uint64 bom_validation_auto_generate_missing_sku_interval = 42;

  int32 mqtt_broker_port = 43;
  string mqtt_hb_interval = 44;
  bool dpu_secure_boot_enabled = 45;

  bool bom_validation_allow_allocation_on_validation_failure = 46;

  string dpa_subnet_ip = 47;
  int32 dpa_subnet_mask = 48;
}

message EchoRequest {
  string message = 1;
}

message EchoResponse {
  string message = 1;
}
// Deprecated DNSMessage format used by Forge DNS service
message DNSMessage {

  message DNSQuestion {
    optional string q_name = 1;  // FQDN including trailing dot
    optional uint32 q_type = 2;  //
    optional uint32 q_class = 3; // Usually 1 (IN)
  }
  message DNSResponse {
    message DNSRR {
      optional string rdata = 5;
    }
    reserved 1; // was: optional uint32 rcode = 1; We now use the gRPC error code for this
    repeated DNSRR rrs = 2;
  }
  optional DNSQuestion question = 1;
  optional DNSResponse response = 2;
}

message DnsRequest {
  string query = 1;
}

message DnsReply {
  string reply = 1;
}

message DomainList {
  repeated Domain domains = 1;
}

message Domain {
  common.DomainId id = 1;
  string name = 2;

  google.protobuf.Timestamp created = 3;
  google.protobuf.Timestamp updated = 4;
  google.protobuf.Timestamp deleted = 5;
}

message DomainDeletion {
  common.DomainId id = 1;
}

message DomainDeletionResult {

}

message DomainSearchQuery {
  optional common.DomainId id = 1;
  optional string name = 2;
}

message ConsoleInput {
  string input = 1;
}

message ConsoleOutput {
  string output = 1;
}

message InstanceEvent {
  string event = 1;
}

message VpcSearchQuery {
  optional common.VpcId id = 1;
  optional string name = 2;
}

message VpcSearchFilter {
  optional string name = 1;
  optional string tenant_org_id = 2;
  optional Label label = 3;
}

message VpcIdList {
  repeated common.VpcId vpc_ids = 1;
}

message VpcsByIdsRequest {
  repeated common.VpcId vpc_ids = 1;
}

message TenantSearchQuery {
  optional string tenantOrganizationId = 1; // protolint:disable:this FIELD_NAMES_LOWER_SNAKE_CASE
}

message Vpc {
  common.VpcId id = 1;
  string name = 2;
  string tenantOrganizationId = 3; // protolint:disable:this FIELD_NAMES_LOWER_SNAKE_CASE

  string version = 99;

  // Not sure if we actually still need those
  google.protobuf.Timestamp created = 4;
  google.protobuf.Timestamp updated = 5;
  google.protobuf.Timestamp deleted = 6;

  optional string tenantKeysetId = 7; // protolint:disable:this FIELD_NAMES_LOWER_SNAKE_CASE
  optional uint32 vni = 8;
  optional VpcVirtualizationType network_virtualization_type = 9;
  Metadata metadata = 10;

  // Sets the desired NSG ID for a VPC
  optional string network_security_group_id  = 11;

  optional uint32 dpa_vni = 12;

  // The ID of the default NVLink Logical Partition for a VPC
  // This is the NVLink Logical Partition that will be used by default for all instances in the VPC.
  optional common.NVLinkLogicalPartitionId default_nvlink_logical_partition_id = 13;

}

message VpcCreationRequest {
  // TODO: Remove the name field as soon as cloud codes gets updated to using metadata.name.
  string name = 2;
  string tenantOrganizationId = 3; // protolint:disable:this FIELD_NAMES_LOWER_SNAKE_CASE
  // this keyset will enable any key contained within it to access any instance associated with this VPC.
  optional string tenantKeysetId = 4; // protolint:disable:this FIELD_NAMES_LOWER_SNAKE_CASE
  optional VpcVirtualizationType network_virtualization_type = 5;

  // Desired ID for this VPC. If the ID is not provided, Forge will generate
  // a random ID.
  // The VPC ID must be unique within the Forge site.
  optional common.VpcId id = 6;
  Metadata metadata = 12;

  // The desired NSG ID and version for a VPC
  optional string network_security_group_id  = 13;

  // The ID of the default NVLink Logical Partition for a VPC
  // This is the NVLink Logical Partition that will be used by default for all instances in the VPC.
  optional common.NVLinkLogicalPartitionId default_nvlink_logical_partition_id = 14;
}

enum VpcVirtualizationType {
  ETHERNET_VIRTUALIZER = 0;
  // 1 was previously FORGE_NATIVE_NETWORKING
  ETHERNET_VIRTUALIZER_WITH_NVUE = 2;
  // Deprecated: FN_CLASSIC and FNN_L3 are deprecated now. Use FNN only.
  FNN_CLASSIC = 3;
  FNN_L3 = 4;
  FNN = 5;
}

message VpcUpdateRequest {
  common.VpcId id = 1;
  // If the field here is set, the update will only be applied if the version
  // is equivalent to the current version on the Forge Site.
  // If a concurrent update changed the site configuration, the API will return
  // a `ConcurrentModificationError`.
  optional string if_version_match = 2;

  // CR question: To avoid the duplication between VpcUpdateRequest and
  // VpcCreationRequest and Vpc - we could move all user configurable fields into
  // a `message VpcConfig/VpcSettings`. However I don't feel like this would add
  // a lot for primitive types like Vpc.

  // TODO: Remove the name field as soon as cloud codes gets updated to using metadata.name.
  string name = 3;
  reserved 4; // was tenantOrganizationId
  reserved 5; // was tenantKeysetId

  // New Metadata to be utilized by the vpc
  Metadata metadata = 6;

  // Sets the desired NSG ID for a VPC
  optional string network_security_group_id  = 17;

  // The ID of the default NVLink Logical Partition for a VPC. This is the
  // NVLink Logical Partition that will be used by default for all instances in the VPC.
  optional common.NVLinkLogicalPartitionId default_nvlink_logical_partition_id = 18;
}

message VpcUpdateResult {
  Vpc vpc = 1;
}

message VpcUpdateVirtualizationRequest {
  // id is the VpcId
  common.VpcId id = 1;

  // If the field here is set, the update will only be applied if the version
  // is equivalent to the current version on the Forge Site.
  // If a concurrent update changed the site configuration, the API will return
  // a `ConcurrentModificationError`.
  optional string if_version_match = 2;

  // network_virtualization_type is the new VpcVirtualizationType
  // to set for the VPC. This is intended for dev use only, and
  // will return an error if any instances are already configured
  // in the VPC.
  optional VpcVirtualizationType network_virtualization_type = 3;
}

message VpcUpdateVirtualizationResult {
}

message VpcDeletionRequest {
  common.VpcId id = 1;
}

message VpcDeletionResult {
}

message VpcList {
  repeated Vpc vpcs = 1;
}

enum PrefixMatchType {
  // Reminder: Protobuf makes the first variant the default value, so we default
  // to an exact match.
  PREFIX_EXACT = 0;
  // Note that for both the "contains" and "contained by" variants, we allow
  // equality to match. That is, if 10.0.0.0/24 is the specified prefix, we
  // consider it to both contain and be contained by that same 10.0.0.0/24
  // prefix if one exists in the database.
  PREFIX_CONTAINS = 1;
  PREFIX_CONTAINED_BY = 2;
}

message VpcPrefix {
  common.VpcPrefixId id = 1;
  string prefix = 2; // Deprecated, use config instead
  string name = 3; // Deprecated, use metadata instead
  common.VpcId vpc_id = 4;
  reserved 5; // tenant_prefix_id
  uint32 total_31_segments = 6; // Deprecated, use status instead
  uint32 available_31_segments = 7; // Deprecated, use status instead

  VpcPrefixConfig config = 8;
  VpcPrefixStatus status = 9;
  Metadata metadata = 10;
}

message VpcPrefixConfig {
  // IPv4 or IPv6 prefix in CIDR notation
  string prefix = 1;
}

message VpcPrefixStatus {
  uint32 total_31_segments = 1;
  uint32 available_31_segments = 2;
}

message VpcPrefixCreationRequest {
  optional common.VpcPrefixId id = 1;
  // IPv4 or IPv6 prefix in CIDR notation
  string prefix = 2; // Deprecated, use config instead
  string name = 3; // Deprecated, use config instead
  common.VpcId vpc_id = 4;
  reserved 5; // tenant_prefix_id
  VpcPrefixConfig config = 6;
  Metadata metadata = 7;
}

message VpcPrefixSearchQuery {
  optional common.VpcId vpc_id = 1;
  optional common.VpcPrefixId tenant_prefix_id = 2;
  optional string name = 3;

  // A prefix to search against, using the prefix_match_type field to
  // determine the search type. (See the comment on the PrefixMatchType enum
  // for its semantics.)
  optional string prefix_match = 4;
  optional PrefixMatchType prefix_match_type = 5;
}

message VpcPrefixGetRequest {
  repeated common.VpcPrefixId vpc_prefix_ids = 1;
}

message VpcPrefixIdList {
  repeated common.VpcPrefixId vpc_prefix_ids = 1;
}

message VpcPrefixList {
  repeated VpcPrefix vpc_prefixes = 1;
}

message VpcPrefixUpdateRequest {
  common.VpcPrefixId id = 1;
  // prefix: CIDR-notation IPv4 or IPv6. If present, it must satisfy:
  // 1. It is the same address family as the old prefix.
  // 2. It is not larger than its containing site prefix.
  // 3. It contains all of its associated network segment prefixes.
  optional string prefix = 2; // Deprecated, use config instead
  optional string name = 3;  // Deprecated, use metadata instead
  VpcPrefixConfig config = 4;
  Metadata metadata = 5;
}

message VpcPrefixDeletionRequest {
  common.VpcPrefixId id = 1;
}

message VpcPrefixDeletionResult {
}

message VpcPeering {
  common.VpcPeeringId id = 1;
  common.VpcId vpc_id = 2;
  common.VpcId peer_vpc_id = 3;
}

message VpcPeeringIdList {
  repeated common.VpcPeeringId vpc_peering_ids = 1;
}

message VpcPeeringList {
  repeated VpcPeering vpc_peerings = 1;
}

message VpcPeeringCreationRequest {
  common.VpcId vpc_id = 1;
  common.VpcId peer_vpc_id = 2;
}

message VpcPeeringSearchFilter {
  optional common.VpcId vpc_id = 1;
}

message VpcPeeringsByIdsRequest {
  repeated common.VpcPeeringId vpc_peering_ids = 1;
}

message VpcPeeringDeletionRequest {
  common.VpcPeeringId id = 1;
}

message VpcPeeringDeletionResult {
}

// Enumerates possible instance states from the view of a tenant
// This is only a subset of total states that the instance might be in, and
// excludes states that are used while the instance is not being allocated to
// a tenant.
enum TenantState {
  // The instance is currently getting provisioned for a tenant
  PROVISIONING = 0;
  // The instance is ready and can be used by the tenant
  READY = 1;
  // The instance has been ready, but the newest configuration that the tenant
  // desired has not been applied yet
  CONFIGURING = 2;
  // The instance is shutting down. Shutdown has not completed yet
  TERMINATING = 3;
  // The instance has fully shut down, and is no longer available for the user
  TERMINATED = 4;
  // The instance is in a terminal failed state. This state is equivalent to
  // DEACTIVATED - no user software is running anymore during the state. However
  // an instance might enter a FAILED state before even fully activating, in case
  // activation failed.
  FAILED = 5;

  // Deprecated in favor of `UPDATING`
  // DPU is being reprovisioned.
  DPU_REPROVISIONING = 6;
  // Deprecated in favor of `UPDATING`
  // Host is doing firmware updates
  HOST_REPROVISIONING = 7;

  // Host or DPU firmware updates
  UPDATING = 8;

  // Something Wrong happened at carbide. Check logs for more info.
  INVALID = 9;
}

// Describe the desired configuration of an IBPartition
message IBPartitionConfig {
  // Deprecated: use Metadata instead  - the name of IBPartition.
  string name = 1;
  // The ID of tenant that IBPartition belong to
  string tenantOrganizationId = 2; // protolint:disable:this FIELD_NAMES_LOWER_SNAKE_CASE

}

// Describe the status and applied configuration of an IBPartition
message IBPartitionStatus {
  // Provisioning state of this partition
  TenantState state = 1;
  // The result of last state controller run - its outcome and an optional reason for that outcome
  optional ControllerStateReason state_reason = 8;
  // The SLA for the current state - and whether the SLA has been breached
  StateSla state_sla = 9;

  // The pkey of IB Partition
  optional string pkey = 2;
  // The partition name of IB Partition
  optional string partition = 3;
  // can be range from 0-15
  optional int32 service_level = 4;
  // can be one of the following: 2, 10, 30, 5, 20, 40, 60, 80, 120, 14, 56, 112, 168, 25, 100, 200, or 300
  optional int32 rate_limit = 5;
  // For IB partitions, value can be 2k or 4k only
  optional int32 mtu = 6;
  // If true, SHARP applications ware created accordingly
  optional bool enable_sharp = 7;
}

// Describe an Infiniband based Partition configuration and status
message IBPartition {
  common.IBPartitionId id = 1;

  IBPartitionConfig config = 2;
  string config_version = 3;

  IBPartitionStatus status = 4;

  Metadata metadata = 5;
}

message IBPartitionList {
  repeated IBPartition ib_partitions = 1;
}

message IBPartitionCreationRequest {
  IBPartitionConfig config = 1;
  // Desired ID for this Partition. If the ID is not provided, Forge will generate
  // a random ID.
  // The Partition ID must be unique within the Forge site.
  optional common.IBPartitionId id = 2;

  Metadata metadata = 3;
}

message IBPartitionDeletionRequest {
  common.IBPartitionId id = 1;
}

message IBPartitionDeletionResult {
}

message IBPartitionSearchFilter {
  optional string tenant_org_id = 1;
  optional string name = 2;
}

message IBPartitionsByIdsRequest {
  repeated common.IBPartitionId ib_partition_ids = 1;
  bool include_history = 2;
}

message IBPartitionIdList {
  repeated common.IBPartitionId ib_partition_ids = 1;
}

// Describe the desired configuration of a PowerShelf
message PowerShelfConfig {
  // The name of PowerShelf.
  string name = 1;
  // Power capacity in watts
  optional int32 capacity = 2;
  // Voltage in volts
  optional int32 voltage = 3;
  // Physical location
  optional string location = 4;
}

// Describe the status and applied configuration of a PowerShelf
message PowerShelfStatus {
  // The result of last state controller run - its outcome and an optional reason for that outcome
  optional ControllerStateReason state_reason = 1;
  // The SLA for the current state - and whether the SLA has been breached
  StateSla state_sla = 2;

  // The shelf name of PowerShelf
  optional string shelf_name = 3;
  // Power state: "on", "off", "standby"
  optional string power_state = 4;
  // Health status: "ok", "warning", "critical"
  optional string health_status = 5;
}

// Describe a PowerShelf configuration and status
message PowerShelf {
  common.PowerShelfId id = 1;

  PowerShelfConfig config = 2;

  PowerShelfStatus status = 3;

  // Timestamp when the power shelf was marked as deleted
  optional google.protobuf.Timestamp deleted = 4;

  string controller_state = 5;
}

message PowerShelfList {
  repeated PowerShelf power_shelves = 1;
}

message PowerShelfCreationRequest {
  PowerShelfConfig config = 1;
  // Desired ID for this PowerShelf. If the ID is not provided, Forge will generate
  // a random ID.
  // The PowerShelf ID must be unique within the Forge site.
  optional common.PowerShelfId id = 2;
}

message PowerShelfDeletionRequest {
  common.PowerShelfId id = 1;
}

message PowerShelfDeletionResult {
}

message PowerShelfStateHistoryRecord {
  string state = 1;
  string version = 2;
  google.protobuf.Timestamp time = 3;
}

message PowerShelfStateHistoriesRequest {
  repeated common.PowerShelfId power_shelf_ids = 1;
}

message PowerShelfStateHistories {
  map<string, PowerShelfStateHistoryRecords> histories = 1;
}

message PowerShelfStateHistoryRecords {
  repeated PowerShelfStateHistoryRecord records = 1;
}

message PowerShelfQuery {
  optional string name = 1;
  common.PowerShelfId power_shelf_id = 2;
}

message ExpectedPowerShelf {
  string bmc_mac_address = 1;
  string bmc_username = 2;
  string bmc_password = 3;
  string shelf_serial_number = 4;
  string ip_address = 5;
  // Metadata that will automatically get associated with a newly created PowerShelf
  Metadata metadata = 6;
  optional common.RackId rack_id = 7;
}

message ExpectedPowerShelfRequest {
  string bmc_mac_address = 1;
}

message ExpectedPowerShelfList {
  repeated ExpectedPowerShelf expected_power_shelves = 1;
}

message LinkedExpectedPowerShelfList {
  repeated LinkedExpectedPowerShelf expected_power_shelves = 1;
}

message LinkedExpectedPowerShelf {
  string shelf_serial_number = 1;
  string bmc_mac_address = 2; // from expected_power_shelves table
  optional common.PowerShelfId power_shelf_id = 3; // The power shelf
}

// Describe the desired configuration of a Switch
message SwitchConfig {
  // The name of Switch.
  string name = 1;
  bool enable_nmxc = 2;
  FabricManagerConfig fabric_manager_config = 3;
  // Physical location
  optional string location = 4;
}

// Describe the desired configuration of Fabric Manager
message FabricManagerConfig {
  map<string, string> config_map = 1;
}

// Describe the status and applied configuration of a Switch
message SwitchStatus {
  // The result of last state controller run - its outcome and an optional reason for that outcome
  optional ControllerStateReason state_reason = 1;
  // The SLA for the current state - and whether the SLA has been breached
  StateSla state_sla = 2;

  // The name of Switch
  optional string switch_name = 3;
  // Power state: "on", "off", "standby"
  optional string power_state = 4;
  // Health status: "ok", "warning", "critical"
  optional string health_status = 5;
}

// Describe a Switch configuration and status
message Switch {
  common.SwitchId id = 1;

  SwitchConfig config = 2;

  SwitchStatus status = 3;

  // Timestamp when the switch was marked as deleted
  optional google.protobuf.Timestamp deleted = 4;

  string controller_state = 5;

  BmcInfo bmc_info = 6;
}

message SwitchList {
  repeated Switch switches = 1;
}

message SwitchCreationRequest {
  SwitchConfig config = 1;
  // Desired ID for this Switch. If the ID is not provided, Forge will generate
  // a random ID.
  // The Switch ID must be unique within the Forge site.
  optional common.UUID id = 2;
}

message SwitchDeletionRequest {
  common.SwitchId id = 1;
}

message SwitchDeletionResult {
}


message SwitchStateHistoryRecord {
  string state = 1;
  string version = 2;
  google.protobuf.Timestamp time = 3;
}

message SwitchStateHistoriesRequest {
  repeated common.SwitchId switch_ids = 1;
}

message SwitchStateHistories {
  map<string, SwitchStateHistoryRecords> histories = 1;
}

message SwitchStateHistoryRecords {
  repeated SwitchStateHistoryRecord records = 1;
}


message SwitchQuery {
  optional string name = 1;
  common.SwitchId switch_id = 2;
}

message ExpectedSwitch {
  string bmc_mac_address = 1;
  string bmc_username = 2;
  string bmc_password = 3;
  string switch_serial_number = 4;
  // Metadata that will automatically get associated with a newly created Switch
  Metadata metadata = 5;
  optional common.RackId rack_id = 6;
  optional string nvos_username = 7;
  optional string nvos_password = 8;
}

message ExpectedSwitchRequest {
  string bmc_mac_address = 1;
}

message ExpectedSwitchList {
  repeated ExpectedSwitch expected_switches = 1;
}

message LinkedExpectedSwitchList {
  repeated LinkedExpectedSwitch expected_switches = 1;
}

message LinkedExpectedSwitch {
  string switch_serial_number = 1;
  string bmc_mac_address = 2; // from expected_switches table
  optional common.SwitchId switch_id = 3; // The switch
}

message IBFabricSearchFilter {
}

message IBFabricIdList {
  repeated string ib_fabric_ids = 1;
}

message NetworkSegmentStateHistory {
  string state = 1;
  string version = 2;
  google.protobuf.Timestamp time = 3;
}

enum NetworkSegmentType {
  TENANT = 0;
  ADMIN = 1;
  UNDERLAY = 2;
  HOST_INBAND = 3;
}

enum NetworkSegmentFlag {
  // This is the default value with no effect (which could potentially be used
  // to make an "empty" set of flags that can't be confused with the default
  // value for a list of flags).
  NO_OP = 0;

  // This marks a segment as one that can "stretch" between multiple VTEPs
  // (read: DPUs) within the site. This used to be implicitly true, but segments
  // created by FNN will not have this flag, which means such a segment exists
  // at a single VTEP in the fabric, and can't have arbitrary extra instances
  // attached to it.
  CAN_STRETCH = 1;
}

message NetworkSegment {
  common.NetworkSegmentId id = 1;
  common.VpcId vpc_id = 2;

  string name = 3;

  optional common.DomainId subdomain_id = 4;
  optional int32 mtu = 5;

  repeated NetworkPrefix prefixes = 6;

  string version = 99;
  TenantState state = 100;
  repeated NetworkSegmentStateHistory history = 101;
  // The result of last state controller run - its outcome and an optional reason for that outcome
  optional ControllerStateReason state_reason = 102;
  // The SLA for the current state - and whether the SLA has been breached
  StateSla state_sla = 103;


  // Not sure if we actually still need those
  google.protobuf.Timestamp created = 11;
  google.protobuf.Timestamp updated = 12;
  google.protobuf.Timestamp deleted = 13;

  NetworkSegmentType segment_type = 14;
  repeated NetworkSegmentFlag flags = 15;
}

message NetworkSegmentCreationRequest {
  common.VpcId vpc_id = 2;

  string name = 3;

  optional common.DomainId subdomain_id = 4;
  optional int32 mtu = 5;

  repeated NetworkPrefix prefixes = 6;

  NetworkSegmentType segment_type = 7;

  // Desired ID for this Network Segment. If the ID is not provided, Forge will generate
  // a random ID.
  // The Network Segment ID must be unique within the Forge site.
  optional common.NetworkSegmentId id = 8;
}

message NetworkSegmentDeletionRequest {
  common.NetworkSegmentId id = 1;
}

message NetworkSegmentDeletionResult {
}

message NetworkSegmentSearchConfig {
  bool include_history = 1;
  bool include_num_free_ips = 2;
}

message NetworkSegmentSearchFilter {
  optional string name = 1;
  optional string tenant_org_id = 2;
}

message NetworkSegmentIdList {
  repeated common.NetworkSegmentId network_segments_ids = 1;
}

message NetworkSegmentsByIdsRequest {
  repeated common.NetworkSegmentId network_segments_ids = 1;
  bool include_history = 2;
  bool include_num_free_ips = 3;
}

message NetworkPrefix {
  common.NetworkPrefixId id = 1;
  string prefix = 2;
  optional string gateway = 3;
  int32 reserve_first = 4;
  reserved 5,6; // deprecated state and events
  // deprecated circuit id.
  reserved 7;
  uint32 free_ip_count = 8;
  optional string svi_ip = 9;
}

message MachineState {
  string state = 1;
}

message InstancePowerRequest {
  // The Machine to perform power operation on.
  // Deprecated: User `instance_id` field instead.
  common.MachineId machine_id = 1;

  enum Operation {
    POWER_RESET = 0;
  }
  Operation operation = 2;

  // Whether the `ipxe_script` script that had been provided during instance creation
  // should be executed again during the next reboot.
  //
  // If the flag is set to `false` or not specified, Forge will only provide the
  // `ipxe_script` script on the first boot attempt. For every subsequent boot,
  // the instance will use the default boot action - which is usually to boot from
  // the hard drive.
  //
  // If the `always_boot_with_ipxe` flag is set during instance creation,
  // Forge will also provide the `ipxe_script` script on every reboot. Thereby the
  // `always_boot_with_ipxe` takes precedence over `boot_with_custom_ipxe`.
  bool boot_with_custom_ipxe = 3;

  // In case update is needed, and user wants to approve, they can inform via this flag.
  // If this flag is true, first update will be performed and then host will be rebooted.
  bool apply_updates_on_reboot = 4;

  // The instance to perform power operation on.
  common.InstanceId instance_id = 5;
}

message InstancePowerResult {
}

message InstanceList {
  repeated Instance instances = 1;
}

message Label {
  string key = 1;
  optional string value = 2;
}

message Metadata {
  string name = 1;
  string description = 2;
  repeated Label labels = 3;
}

message InstanceSearchFilter {
  // supports filtering on key, value, or key and value
  optional Label label = 1;
  optional string tenant_org_id = 2;
  optional string vpc_id = 3;
  optional string instance_type_id = 4;
}

message InstanceIdList {
  repeated common.InstanceId instance_ids = 1;
}

message InstancesByIdsRequest {
  repeated common.InstanceId instance_ids = 1;
}

message InstanceAllocationRequest {
  // The Machine on top of which we create an Instance
  // If we go towards "we already have instances model", this would become more of a
  // AssignInstanceToTenant request, and the ID would be the instance_id
  common.MachineId machine_id = 1;


  // Desired configuration for the allocated instance
  InstanceConfig config = 2;

  // Desired ID for this Instance. If the ID is not provided, Forge will generate
  // a random ID.
  // The Instance ID must be unique within the Forge site.
  optional common.InstanceId instance_id = 3;

  // The expected InstanceTypeId of the machine associated
  // with the Instance. If sent and the machine of the request has
  // a different type ID, the request will be rejected.
  optional string instance_type_id = 4;

  reserved 11; // Was ssh_keys - replaced by tenantKeysetId in InstanceConfig.TenantConfig instead.
  Metadata metadata = 12;

  // Allow allocation on unhealthy machines
  bool allow_unhealthy_machine = 13;
}

// Batch instance allocation request
message BatchInstanceAllocationRequest {
  // List of instance allocation requests to be processed in a single transaction
  // All instances will be allocated atomically - if any fails, all will be rolled back
  repeated InstanceAllocationRequest instance_requests = 1;
}

// Batch instance allocation response
message BatchInstanceAllocationResponse {
  // List of successfully allocated instances
  repeated Instance instances = 1;
}

// Tenant related configuration that is set once the instance is allocated
// by a tenant
message TenantConfig {
  // Identifies the tenant that uses this instance
  string tenant_organization_id = 1;

  // These fields have been used for OS configuration in the past.
  // They are now replaced with the OperatingSystem message.
  reserved 11, 12, 13, 14;

  optional string hostname = 15;

  //TODO: make an API that allows these to be updated.  For now, they're set only at instance allocation.
  // protolint:disable:next FIELD_NAMES_LOWER_SNAKE_CASE
  repeated string tenantKeysetIds = 8; // this may be empty
}

message OperatingSystem {
  // Contains the operating system definition based on the variant of operating system
  oneof variant {
    InlineIpxe ipxe = 1;
    common.UUID os_image_id = 2;
  }

  // If this flag is set to `true` the instance will not transition to a Ready state until
  // InstancePhoneHomeLastContact is updated
  bool phone_home_enabled = 11;

  // If this flag is set to `true`, the instance will run the provisioning instructions
  // that are specified by the OS on every reboot attempt.
  // Depending on the type of provisioning instructions, this might
  // lead the instance to reinstall itself on every reboot.
  //
  // E.g. if the instance uses an iPXE script as OS and the iPXE scripts contains
  // instructions for installing on a local disk, the installation would be repeated
  // on the reboot.
  //
  // If the flag is set to `false` or not specified, Forge will only provide
  // iPXE instructions that are defined by the OS definition on the first boot attempt.
  // For every subsequent boot, the instance will use the default boot action - which
  // is usually to boot from the hard drive.
  //
  // If the provisioning instructions should only be used on specific reboots
  // in order to trigger reinstallation, tenants can use the `InvokeInstancePower`
  // API to reboot instances with the `boot_with_custom_ipxe` parameter set to
  // `true`.
  bool run_provisioning_instructions_on_every_boot = 12;
  // tenant cloud-init script for any type of OS, preferred
  optional string user_data = 13;
}

message InlineIpxe {
  // The iPXE script which is booted into
  string ipxe_script = 1;
  // Optional user-data that is associated with the iPXE script
  // This can be a cloud-init script
  // Deprecated, use OperatingSystem user_data field
  optional string user_data = 2;
}

// Desired configuration for an instance
message InstanceConfig {
  // Tenant related configuration.
  // This field can be absent if the instance has not yet been allocated by
  // a tenant. On assignment, the config changes once. Due to the one-time
  // change no version field is required.
  TenantConfig tenant = 1;

  // Operating system. This is required if no operating system reference is provided
  OperatingSystem os = 2;
  // Can be used to reference an OS in the OS library based on a unique ID
  // string os_reference = 3;

  // Configures instance networking configurations
  InstanceNetworkConfig network = 11;

  // Configures instance infiniband configurations.
  InstanceInfinibandConfig infiniband = 12;

  reserved 21;

  // The ID of security group that is attached to this instance.
  // Takes precedence over any NSG set on the parent VPC.
  // Superseded by any NSG set on an individual interface.
  optional string network_security_group_id = 22;

  // Configures instance extension services (e.g., SDN components)
  optional InstanceDpuExtensionServicesConfig dpu_extension_services = 23;

  // Configures instance nvlink partitions
  InstanceNVLinkConfig nvlink = 24;

}

// Desired network configuration for an instance
message InstanceNetworkConfig {
  // Configures how instance network interfaces are set up
  repeated InstanceInterfaceConfig interfaces = 1;
}

// Desired infiniband configuration for an instance
message InstanceInfinibandConfig {
  // Configures how instance infiniband interfaces are set up
  repeated InstanceIBInterfaceConfig ib_interfaces = 1;
}

message InstanceDpuExtensionServiceConfig {
  string service_id = 1;
  string version = 2;
}

// Extension services configuration for an instance
message InstanceDpuExtensionServicesConfig {
  repeated InstanceDpuExtensionServiceConfig service_configs = 1;
}
// Desired nvlink configuration for an instance
message InstanceNVLinkConfig {
  // Configures how instance nvlink gpus are set up
  repeated InstanceNVLinkGpuConfig gpu_configs = 1;
}

// New configuration for the instances network interfaces
// This completely overwrites the existing interfaces, so it would be up on the caller
// to make sure the new settings are consistent and old interfaces that should not be
// touched are listed here again.
// A change in any entry of `InstanceNetworkConfig::interface_configs` can be interpreted by
// Forge as deleting the old interface and replacing it with a new interface.
// Note: This is commented because we will not immediately implement the method
// message InstanceNetworkConfigUpdateRequest {
//   // The ID of the instance that should get an updated networking configuration
//   common.InstanceId instance_id = 1;

//   // If the field here is set, the update will only be applied if the version
//   // is equivalent to the current network config version on the Forge Site.
//   // If a concurrent update changed the site configuration, the API will return
//   // a `ConcurrentModificationError`.
//   optional string if_version_match = 2;

//   // The updated instance network configuration
//   InstanceNetworkConfig network_config = 3;
// }

// Updates the operating system utilized by an instance
message InstanceOperatingSystemUpdateRequest {
  // The ID of the instance that should get an updated operating system
  common.InstanceId instance_id = 1;

  // If the field here is set, the update will only be applied if the version
  // is equivalent to the current instance config version on the Forge Site.
  // If a concurrent update changed the site configuration, the API will return
  // a `ConcurrentModificationError`.
  optional string if_version_match = 2;

  // Operating system. This is required if no operating system reference is provided
  OperatingSystem os = 3;
  // Can be used to reference an OS in the OS library based on a unique ID
  // string os_reference = 4;
}

// Updates the configuration utilized by an instance
message InstanceConfigUpdateRequest {
  // The ID of the instance for which the config update will apply
  common.InstanceId instance_id = 1;

  // If the field here is set, the update will only be applied if the version
  // is equivalent to the current instance config version on the Forge Site.
  // If a concurrent update changed the site configuration, the API will return
  // a `ConcurrentModificationError`.
  optional string if_version_match = 2;

  // New configuration to be utilized by the instance
  InstanceConfig config = 3;
  // New Metadata to be utilized by the instance
  Metadata metadata = 4;
}

// Current status of an instance
message InstanceStatus {
  // Status that is related to the tenant of the instance.
  // In case no tenant has been assigned to this instance, the field would be absent.
  optional InstanceTenantStatus tenant = 1;

  // Note: There will be a separate state for the states
  // that are only important for the site admin and forge team.
  // That state is at the moment defined on `message Machine`, but might
  // be carried over. It's outside of the scope of this change.

  // Status of the networking subsystem of an instance
  InstanceNetworkStatus network = 11;

  // Status of the infiniband subsystem of an instance
  InstanceInfinibandStatus infiniband = 12;

  reserved 21;

  // Status of attached extension services of an instance
  InstanceDpuExtensionServicesStatus dpu_extension_services = 22;
  // Whether all configurations related to an instance are in-sync.
  // This is a logical AND for the settings of all sub-configurations.
  // At this time it equals `InstanceNetworkStatus::configs_synced`,
  // but might in the future also include readiness for other subsystems.
  SyncState configs_synced = 101;

  // This indicates if updates are pending for the instance
  optional InstanceUpdateStatus update = 102;

  InstanceNVLinkStatus nvlink = 103;
}

// State of the networking subsystem of an instance
message InstanceNetworkStatus {
  // Status for each configured interface
  //
  // Each entry in this status array maps to its corresponding entry in the
  // Config section. E.g. `instance.status.network.interface_status[1]`
  // would map to `instance.config.network.interface_configs[1]`.
  repeated InstanceInterfaceStatus interfaces = 1;

  // Whether all desired network changes that the user has applied have taken effect
  // This includes:
  // - Whether `InstanceNetworkConfig` is of exactly the same version as the
  //   version the user desires.
  // - Whether the version of each security policy that is either directly referenced
  //   as part of an `InstanceInterfaceConfig` or indirectly referenced via the
  //   the security policies that are applied to the VPC or NetworkSegment
  //   is exactly the same version as the version the user desires.
  //
  // Note for the implementation: We need to monitor all these config versions
  // on the feedback path from DPU to carbide in order to know whether the
  // changes have indeed taken effect.
  // TODO: Do we also want to show all applied versions here, or just track them
  // internally? Probably not help for for tenants at all - but it could be helpful
  // for the Forge operating team to debug settings that to do do not go in-sync
  // without having to attach to the database.
  SyncState configs_synced = 101;
}

// State of the infiniband subsystem of an instance
message InstanceInfinibandStatus {
  // Status for each configured interface
  //
  // Each entry in this status array maps to its corresponding entry in the
  // Config section. E.g. `instance.status.network.ib_interface_status[1]`
  // would map to `instance.config.network.ib_interface_configs[1]`.
  repeated InstanceIBInterfaceStatus ib_interfaces = 1;

  // Whether all desired infiniband changes that the user has applied have taken effect
  // This includes:
  // - Whether `InstanceInfinibandConfig` is of exactly the same version as the
  //   version the user desires.
  //
  // TODO: Do we also want to show all applied versions here, or just track them
  // internally? Probably not help for for tenants at all - but it could be helpful
  // for the Forge operating team to debug settings that to do do not go in-sync
  // without having to attach to the database.
  SyncState configs_synced = 101;
}

message DpuExtensionServiceStatus {
  common.MachineId dpu_machine_id = 1;
  DpuExtensionServiceDeploymentStatus status = 2;
  optional string error_message = 3;
  repeated DpuExtensionServiceComponent components = 4;
}

message InstanceDpuExtensionServiceStatus {
  string service_id = 1;
  string version = 2;
  DpuExtensionServiceDeploymentStatus deployment_status = 3;
  repeated DpuExtensionServiceStatus dpu_statuses = 4;
  optional string removed = 5;
}

// Status of extension services subsystem of an instance
message InstanceDpuExtensionServicesStatus {
  repeated InstanceDpuExtensionServiceStatus dpu_extension_services = 1;
  SyncState configs_synced = 101;
}

message InstanceNVLinkStatus {
  repeated InstanceNVLinkGpuStatus gpu_statuses = 1;
  SyncState configs_synced = 101;
}

// Contains all information about an actively running instance
// This entails both the instance configuration, as well as the current state of the instance
message Instance {
  // Instance ID
  common.InstanceId id = 1;
  // The ID of the host machine which is utilized for this Instance (host_machine_id)
  common.MachineId machine_id = 2;
  Metadata metadata = 3;

  // The InstanceTypeId associated with the Instance.
  // This is inherited from its Machine upon creation
  // and cannot be changed.  It technically can't even be
  // optional, unlike on Machine, since allocations should
  // come from pools defined by InstanceTypes.
  optional string instance_type_id = 4;

  // TPM EK certificate in base64 format
  optional string tpm_ek_certificate = 5;

  // The desired configuration on the instance
  InstanceConfig config = 103;

  // The most recent status of the instance that has been observed
  InstanceStatus status = 104;

  // Current version of the networking configuration that is applied on the instance
  // This field can be used in InstanceNetworkConfigUpdateRequest::if_version_match
  // to only request updates if the version hasn't been updated in between.
  string network_config_version = 201;

  // Current version of the infiniband configuration that is applied on the instance
  // This field can be used in InstanceInfinibandConfigUpdateRequest::if_version_match
  // to only request updates if the version hasn't been updated in between.
  string ib_config_version = 202;

  // Current version of the instance configuration
  // This field can be used in `if_version_match` fields in various instance update
  // requests in order to request only applying updates if the version hasn't been
  // updated in between.
  //
  // This version field versions all instance data except networking configurations.
  // In a future version of Forge we might however remove the separate network
  // configuration versioning.
  string config_version = 203;
  // todo: not sure if we need a storage specific config version or we can use
  // the instance config version above.
  reserved 204;
  // Current version of the extension service configuration that is applied on the instance
  string dpu_extension_service_version = 205;
  string nvlink_config_version = 206;
}

message InstanceUpdateStatus {
  enum Module {
    Dpu = 0;
  }

  Module module = 1;
  string initiator = 2;
  google.protobuf.Timestamp trigger_received_at = 3;
  optional google.protobuf.Timestamp update_triggered_at = 4;
  bool user_approval_received = 5;
}

// The configuration that a customer desires for an instances network interface
message InstanceInterfaceConfig {
  // Whether the user wants to create a physical or virtual function
  InterfaceFunctionType function_type = 1;

  // Network segment ID can change. It if changes - we require a new IP address
  common.NetworkSegmentId network_segment_id = 3;

  // Cloud can send prefix id as well.
  oneof network_details {
    common.NetworkSegmentId segment_id = 5;
    // In case of vpc_prefix_id, carbide should allocate a network segment
    // and continue IP allocation.
    common.VpcPrefixId vpc_prefix_id = 6;
  }

  // The ID of security group that is attached to this interface
  // Note: This is commented because we will not supported setting these in the first
  // release of the new Instance API
  // optional common.UUID security_group_id = 4;

  // The name of the device that gets configured
  optional string device = 7;

  // If multiple devices with the same name - and connected to the same
  // fabric - are available, this selects the device among these. This paramter will
  // increment for each network device.
  //
  // Device Instance 0 represents the primary device
  // All non-primary devices are sorted by slot number
  //
  // Forge will the above strategy to achieve deterministic device selection
  // via `device_instance`.
  uint32 device_instance = 8;

  // If the interface is defined as a virtual function (associated
  // `InstanceInterfaceConfig.function_type == InterfaceFunctionType::VIRTUAL_FUNCTION`,
  // then this value is set and specifies the virtual function ID that is configured
  // for this network interface.
  optional uint32 virtual_function_id = 9;
}

// The configuration that a customer desires for an instances IB interface
message InstanceIBInterfaceConfig {
  // The name of the device that gets configured
  string device = 1;

  // The device vendor.
  optional string vendor = 2;

  reserved 3; // fabric

  // If multiple devices with the same name - and connected to the same
  // fabric - are available, this selects the device among these.
  // `device_instance == 1` selects the 2nd device of a certain type.
  //
  // Forge will internally order devices of the same type by PCI slot in order
  // to achieve deterministic device selection via `device_instance`.
  uint32 device_instance = 4;

  // Whether the interface is a physical or virtual function
  // In the case of a virtual function the associated
  // `virtual_function_id` describes the ID of the interface
  InterfaceFunctionType function_type = 11;

  // If the interface is defined as a virtual function (associated
  // `InstanceInterfaceConfig.function_type == InterfaceFunctionType::VIRTUAL_FUNCTION`,
  // then this value is set and specifies the virtual function ID that is configured
  // for this network interface.
  optional uint32 virtual_function_id = 12;

  // The actual configuration for the device
  common.IBPartitionId ib_partition_id = 21;
}

// The actual status of a single network interface of an instance
message InstanceInterfaceStatus {
  // If the interface is defined as a virtual function (associated
  // `InstanceInterfaceConfig.function_type == InterfaceFunctionType::VIRTUAL_FUNCTION`,
  // then this value is set and specifies the virtual function ID that is configured
  // for this network interface.
  optional uint32 virtual_function_id = 1;

  // The MAC address which has been assigned to this interface
  // The list will be empty if interface configuration hasn't been completed
  // and therefore the address is unknown.
  optional string mac_address = 2;

  // The list of IP addresses that had been assigned to this interface,
  // based on the requested subnet.
  // The list will be empty if interface configuration hasn't been completed
  repeated string addresses = 3;

  // The list of gateways, in CIDR notation, one for each address in `addresses`.
  repeated string gateways = 4;

  // The list of IP prefixes that have been assigned to this interface
  // out of the requested subnet (where the prefix allocated to the interface
  // may be a /30 in the case of FNN, or just a /32 in the case of ETV).
  //
  // This is similar to `gateways`, in that there is one `prefix` for each
  // address in `addresses`.
  repeated string prefixes = 5;

  optional string device = 6;
  uint32 device_instance = 7;
}

// The actual status of a single IB interface of an instance
message InstanceIBInterfaceStatus {
  // The GUID of the hardware device that this interface is attached to
  optional string pf_guid = 1;

  // The GUID which has been assigned to this interface
  // In case the interface is a PF interface, the GUID will be equivalent to
  // `pf_guid` - which is the GUID that is stored on the hardware device.
  // For a VF interface, this is a GUID that has been allocated by Forge in order
  // be used for the VF.
  // Tenants have to configure the VF device on their instances to use this GUID.
  optional string guid = 2;

  // The local id of this IB interface; if interface configuration has not been completed, the value is 0.
  uint32 lid = 11;

  // The list of IP addresses that had been assigned to this interface,
  // based on the requested partition.
  // The list will be empty if interface configuration hasn't been completed or IPoIB disabled
  // TODO: This is for future use - once once Forge supports IP over IB
  // repeated string addresses = 21;
}

// The actual status of a single gpu of an instance
message InstanceNVLinkGpuStatus {
  /// fabric guid of this GPU
  optional string gpu_guid = 1;

  /// The NVLink domain this GPU is physically a part of
  common.NVLinkDomainId domain_id = 2;

  // Logical partition this GPU is in
  common.NVLinkLogicalPartitionId logical_partition_id = 3;
}


// The configuration that a customer desires for an instances NVLink GPUs
message InstanceNVLinkGpuConfig {
  uint32 device_instance = 1;

  // logical partition gpu is part of
  common.NVLinkLogicalPartitionId logical_partition_id = 2;
}

message InstancePhoneHomeLastContactRequest {
  common.InstanceId instance_id = 1;
}

message InstancePhoneHomeLastContactResponse {
  google.protobuf.Timestamp timestamp = 1;
}

// Enum defining different categories of issues that can be reported during instance release
enum IssueCategory {
  UNSPECIFIED = 0;
  HARDWARE = 1;
  NETWORK = 2;
  PERFORMANCE = 3;
  OTHER = 4;
}

// Message containing details about an issue reported during instance release
message Issue {
  IssueCategory category = 1; // Category of issue
  string summary = 2; // User-friendly summary of the issue
  string details = 3; // Additional context about the issue
}

message InstanceReleaseRequest {
  common.InstanceId id = 1;
  // Optional issue information if tenant is reporting a problem
  optional Issue issue = 2;
  // Optional flag indicating the call is from repair tenant (default: false)
  optional bool is_repair_tenant = 3;
}

message InstanceReleaseResult {
}

message MachinesByIdsRequest {
  repeated common.MachineId machine_ids = 1;
  bool include_history = 2;
}

message MachineSearchConfig {
  bool include_dpus = 1;
  bool include_history = 2;
  bool include_predicted_host = 3;
  bool only_maintenance = 4;
  reserved 5; // Was: bool include_associated_machine_id = 5; Now always included
  bool exclude_hosts = 6;
  bool only_quarantine = 7;
  optional string instance_type_id = 8;
  bool mnnvl_only = 9;
}

message MachineStateHistoriesRequest {
  repeated common.MachineId machine_ids = 1;
}

message MachineStateHistories {
  // The History for each Machine
  map<string, MachineStateHistoryRecords> histories = 1;
}

// A list of Machine history records, starting by the oldest
message MachineStateHistoryRecords {
  repeated MachineEvent records = 1;
}

message MachineHealthHistoriesRequest {
  repeated common.MachineId machine_ids = 1;
  // Optional: Start time of the range (inclusive) for filtering health history
  google.protobuf.Timestamp start_time = 2;
  // Optional: End time of the range (inclusive) for filtering health history
  google.protobuf.Timestamp end_time = 3;
}

message MachineHealthHistories {
  // The Health History for each Machine
  map<string, MachineHealthHistoryRecords> histories = 1;
}

// A list of Machine health history records, starting by the oldest
message MachineHealthHistoryRecords {
  repeated MachineHealthHistoryRecord records = 1;
}

// The observed health for a Machine at a certain point in time
message MachineHealthHistoryRecord {
  // The observed health
  health.HealthReport health = 1;
  // The time when the health was observed
  google.protobuf.Timestamp time = 2;
}

message TenantByOrganizationIdsRequest {
  repeated string organization_ids = 1;
}

message TenantSearchFilter {
  optional string tenant_organization_name = 1;
}

message TenantList {
  repeated Tenant tenants= 1;
}

message TenantOrganizationIdList {
  repeated string tenant_organization_ids = 1;
}

message InterfaceList {
  repeated MachineInterface interfaces = 1;
}

message MachineList {
  repeated Machine machines = 1;
}

message InterfaceDeleteQuery {
  common.MachineInterfaceId id = 1;
}

message InterfaceSearchQuery {
  optional common.MachineInterfaceId id = 1;
  optional string ip = 2;
}

enum MachineType {
  UNKNOWN = 0;
  DPU = 1;
  HOST = 2;
  POWER_SHELF = 3;
}

message BmcInfo {
  optional string ip = 1;
  optional string mac = 2;
  optional string version = 3;
  optional string firmware_version = 4;
  optional uint32 port = 5;
}

message Machine {
  // Uniquely identifies a Forge machine.
  // The value of this field is globally unique.
  common.MachineId id = 1;

  reserved 4, 5, 6; // Used for timestamps in the past

  // The current lifecycle state of the machine
  string state = 7;
  // Version field that is associated with the `state` of the machine.
  // Every time the lifecycle state of the `Machine` changes for any reason, the version field will be updated.
  string state_version = 13;
  // The result of last state controller run - its outcome and an optional reason for that outcome
  optional ControllerStateReason state_reason = 25;
  // The SLA for the current state - and whether the SLA has been breached
  StateSla state_sla = 31;

  // The history of the state for the machine. Only populated if `include_history` is set.
  repeated MachineEvent events = 8;

  // Note: This is not yet removed in this change to limit the amount of breaking
  // changes at once - but users shouldn't rely on it. The actually interesting
  // information around interfaces for Instance users is in `Instance::InstanceNetworkStatus`.
  repeated MachineInterface interfaces = 9;

  // TODO: This field might actually move Instance since the discovered hardware
  // could be different per lifecycle. When the machine is updated with different
  // hardware and restarted, the data can change. The Instance would have the
  // capability to store the actual discovery information for each lifecycle
  optional machine_discovery.DiscoveryInfo discovery_info = 10;

  // Machine type if it is a DPU or HOST.
  MachineType machine_type = 11;

  BmcInfo bmc_info = 12;

  google.protobuf.Timestamp last_reboot_time = 14;
  // This is used by legacy versions of forge-admin-cli as well as by Forge Cloud
  reserved 15; // Was NetworkHealth network_health = 15;
  google.protobuf.Timestamp last_observation_time = 16;
  optional string maintenance_reference = 17;
  optional google.protobuf.Timestamp maintenance_start_time = 18;

  // Other machine ids associated with this machine
  optional common.MachineId associated_host_machine_id = 19;
  // Deprecated, use associated_dpu_machine_ids. For now, this is filled in with the first DPU ID.
  // TODO: Once all admin CLI clients have updated, drop this and stop filling it in.
  optional common.MachineId associated_dpu_machine_id = 20;

  optional MachineInventory inventory = 21;
  optional google.protobuf.Timestamp last_reboot_requested_time = 22;
  optional string last_reboot_requested_mode = 23;

  optional string dpu_agent_version = 24;

  // Fields are not ordered numerically, check the whole message for max field number
  repeated common.MachineId associated_dpu_machine_ids = 26;

  // For Host Machines returns the aggregate health of the host
  // For DPUs, it returns the individual DPU health
  health.HealthReport health = 27;

  // Informs whether any overrides (identified by a specific source name and mode) are applied
  // to health
  repeated HealthOverrideOrigin health_overrides = 29;

  optional bool firmware_autoupdate = 28;

  optional string failure_details = 30;

  // Infiniband devices information attached to the machine.
  optional InfinibandStatusObservation ib_status = 32;

  // Metadata associated with the Machine
  Metadata metadata = 33;

  // Version field that tracks changes to
  // - Metadata
  string version = 34;

  // Restrictions on the network configuration for any instances that can be allocated on this machine.
  optional InstanceNetworkRestrictions instance_network_restrictions = 35;

  // The instance type with which a machine is associated if any.
  optional string instance_type_id = 36;

  // The known capabilities of a machine
  MachineCapabilitiesSet capabilities = 37;

  optional string hw_sku = 38;
  optional SkuStatus hw_sku_status = 39;

  optional ManagedHostQuarantineState quarantine_state = 40;

  optional string hw_sku_device_type = 41;

  bool update_complete = 42;

  optional MachineNVLinkInfo nvlink_info = 43;

  optional MachineNVLinkStatusObservation nvlink_status_observation = 44;
}

message InstanceNetworkRestrictions {
  // Describes how instances machine can connect to network segments. See [`NetworkSegmentMembershipType`] for details.
  InstanceNetworkSegmentMembershipType network_segment_membership_type = 1;
  // If network_segment_membership_type is `STATIC`, this spells out what network segment ID's are available on the
  // host. If it is `TENANT_CONFIGURABLE`, it lists what network segment ID's are available to be configured when an
  // instance is allocated (empty for no limitations.) Currently this will always be empty if
  // network_segment_membership_type is TENANT_CONFIGURABLE
  repeated common.NetworkSegmentId network_segment_ids = 2;
}

// Describes how a machine can connect to network segments.
//
// - `TENANT_CONFIGURABLE` means tenants can specify what network segments they want to make available to instances on this host.
// - `STATIC` means the machine's in-band network interfaces have direct access to their network segments, and cannot be
// configured at changed by carbide (ie. their VLAN membership is configured in a switch somewhere, etc.)
enum InstanceNetworkSegmentMembershipType {
  TENANT_CONFIGURABLE = 0;
  STATIC = 1;
}

// Updates the Metadata stored on a Machine
message MachineMetadataUpdateRequest {
  // The ID of the Machine for which the Metadata update will apply
  common.MachineId machine_id = 1;

  // If the field here is set, the update will only be applied if the version
  // is equivalent to the current Machine `version` on the Forge Site.
  // If a concurrent update changed the site configuration, the API will return
  // a `ConcurrentModificationError`.
  optional string if_version_match = 2;

  // New Metadata to be utilized by the Machine
  Metadata metadata = 3;
}

message DpuAgentInventoryReport {
  common.MachineId machine_id = 1;
  MachineInventory inventory = 2;
}

message MachineInventory {
  repeated MachineInventorySoftwareComponent components = 1;
}

message MachineInventorySoftwareComponent {
  string name = 1;
  string version = 2;
  string url = 3;
}

// A health override that is applied to a Host
message HealthOverrideOrigin {
  OverrideMode mode = 1;
  string source = 2;
}

// Result of last state controller iteration
message ControllerStateReason {
  ControllerStateOutcome outcome = 1;
  optional string outcome_msg = 2;
  optional ControllerStateSourceReference source_ref = 3;
}

enum ControllerStateOutcome {
  WAIT = 0;
  ERROR = 1;
  TRANSITION = 2;
  DO_NOTHING = 3;
  TODO = 4;
}

// Location in the Source Code that lead to the specific state handling outcome
message ControllerStateSourceReference {
  string file = 1;
  int32 line = 2;
}

message StateSla {
  // The SLA for the current state
  // This field will be absent if there is no SLA defined for a field
  // A value of 0 (instead of absent) will indicate the `time_in_state` will always
  // be above SLA. This can happen for certain states that should never be entered
  // for correct operation.
  google.protobuf.Duration sla = 1;
  // Whether the object has been in the state for a longer time than permitted
  // by the SLA.
  bool time_in_state_above_sla = 2;
}

// The most recent tenant related status
message InstanceTenantStatus {
  // The current state of the instance from the point of view of the assigned tenant
  TenantState state = 1;
  // An optional message which can contain details about the state
  string state_details = 2;
}

enum SyncState {
  // All configuration changes that users requested have been applied
  SYNCED = 0;
  // At least one configuration change to an active instance has not yet been processed
  PENDING = 1;
}

enum MachineArchitecture {
  ARM = 0;
  X86 = 1;
}

message MachineEvent {
  reserved 1; // previously int64 id = 1;
  reserved 2; // previously common.MachineId machine_id = 2;

  // The lifecycle state of the Machine
  string event = 3;
  // The version field that is associated with the state change
  string version = 5;
  // The time when the state changed
  google.protobuf.Timestamp time = 4;
}

enum InterfaceAssociationType {
  NONE = 0;
  MACHINE = 1;
  SWITCH = 2;
  POWERSHELF = 3;
}

message MachineInterface {
  common.MachineInterfaceId id = 1;
  optional common.MachineId attached_dpu_machine_id = 2;
  common.MachineId machine_id = 3;
  common.NetworkSegmentId segment_id = 4;

  string hostname = 5;

  common.DomainId domain_id = 6;

  bool primary_interface = 7;
  string mac_address = 8;

  repeated string address = 9;
  optional string vendor = 10;

  google.protobuf.Timestamp created = 11;
  optional google.protobuf.Timestamp last_dhcp = 12;

  optional bool is_bmc = 13;
  optional common.PowerShelfId power_shelf_id = 14;
  optional common.SwitchId switch_id = 15;

  optional InterfaceAssociationType association_type = 16;
}

// Infiniband interface status description
message InfinibandStatusObservation {
  // The actual/observed state of all InfiniBand interfaces in Machine
  repeated MachineIbInterface ib_interfaces = 1;
  // When the IB status was last observed
  optional google.protobuf.Timestamp observed_at = 2;
}

// Observed state of a single IB interface
// This is the information that Carbide collects from UFM
message MachineIbInterface {
  // The GUID of the hardware device that this interface is attached to
  optional string pf_guid = 1;

  // The GUID which has been assigned to this interface
  // In case the interface is a PF interface, the GUID will be equivalent to
  // `pf_guid` - which is the GUID that is stored on the hardware device.
  // For a VF interface, this is a GUID that has been allocated by Forge in order
  // be used for the VF.
  // Tenants have to configure the VF device on their instances to use this GUID.
  optional string guid = 2;

  // The local id of this IB interface; if interface configuration has not been completed, the value is 0.
  // This value is 0xffff for devices in non active state.
  optional uint32 lid = 11;

  // The ID of the fabric on which the GUID has been observed
  // This is empty if the GUID hasn't been observed on any fabric
  optional string fabric_id = 3;

  reserved 4; // used for associated_pkeys in a different format in a previous release

  // Partition keys currently associated with the interface at UFM
  // The value of this field is null in case the associated_pkeys could not be determined
  // The value is an empty list in case there are no pkeys associated with the interface
  optional common.StringList associated_pkeys = 5;

  // Partition IDs currently associated with the interface at UFM
  // None means the associated pkeys could not be determined.
  // The amount of IDs can be different than the amount of `associated_pkeys`
  // in case a pkey that is associated with the port does not map to any
  // partition ID.
  optional common.StringList associated_partition_ids = 6;
}

message DhcpDiscovery {
  string mac_address = 1;
  string relay_address = 2;
  optional string vendor_string = 3;
  optional string link_address = 4;
  optional string circuit_id = 5;
  optional string remote_id = 6;
  optional string desired_address = 7;
}

message DhcpRecord {
  common.MachineId machine_id = 1;
  common.MachineInterfaceId machine_interface_id = 2;
  common.NetworkSegmentId segment_id = 3;
  common.DomainId subdomain_id = 4;

  string fqdn = 5;
  string mac_address = 6;
  string address = 7;

  int32 mtu = 8;

  string prefix = 9;

  optional string gateway = 10;

  optional string booturl = 11;

  // The last time any underlay or admin DHCP record managed by Forge got invalidated
  optional google.protobuf.Timestamp last_invalidation_time = 12;
}

message NetworkSegmentList {
  repeated NetworkSegment network_segments = 1;
}

message SSHKeyValidationRequest {
  string user = 1;
  string pubkey = 2;
}

enum UserRoles {
  USER = 0;
  ADMINISTRATOR = 1;
  OPERATOR = 2;
  NOACCESS = 3;
}

message SSHKeyValidationResponse {
  bool is_authenticated = 1;
  UserRoles role = 2;
}

message CredentialRequest {
  string host_id = 1; // UUID, IP address, host name or MAC address
}

message CredentialResponse {
  string username = 1;
  string password = 2;
}

message GetSiteExplorationRequest {

}

message ClearSiteExplorationErrorRequest {
  // The IP address of the BMC whose error should be cleared from the explored_endpoints table
  string ip_address = 1;
}

message ReExploreEndpointRequest {
  // The IP address of the BMC endpoint which should be explored again
  string ip_address = 1;
  // If this is set, it will schedule re-exploration of the endpoint only if the
  // report version number is equivalent to the version in the request
  optional string if_version_match = 2;
}

message DeleteExploredEndpointRequest {
  // The IP address of the BMC endpoint to delete
  string ip_address = 1;
}

message PauseExploredEndpointRemediationRequest {
  // The IP address of the BMC endpoint for which to pause/unpause remediation
  string ip_address = 1;
  // Whether to pause (true) or unpause (false) remediation actions
  bool pause = 2;
}

message DeleteExploredEndpointResponse {
  // Whether the endpoint was successfully deleted
  bool deleted = 1;
  // Optional message with additional information
  optional string message = 2;
}

message BmcEndpointRequest {
  // IP address of the BMC to act on
  string ip_address = 1;
  // The MAC the host DHCPed from
  optional string mac_address = 2;
}

message SshTimeoutConfig {
  // TCP Connection Timeout (seconds)
  optional uint64 tcp_connection_timeout = 1;
  // TCP Read Timeout (seconds)
  optional uint64 tcp_read_timeout = 2;
  // TCP Write Timeout (seconds)
  optional uint64 tcp_write_timeout = 3;
  // SSH Session Timeout (seconds)
  optional uint64 ssh_session_timeout = 4;
}

message SshRequest {
  // BMC Endpoint Request
  BmcEndpointRequest endpoint_request = 1;
  reserved 2; // deprecated -- timeout_config
}

message CopyBfbToDpuRshimRequest {
  SshRequest ssh_request = 1;
  reserved 2;
}

message UpdateMachineHardwareInfoRequest {
  // Machine ID to update
  common.MachineId machine_id = 1;
  MachineHardwareInfo info = 2;
  // Which hardware info to update.
  MachineHardwareInfoUpdateType update_type = 3;
}

message MachineHardwareInfo {
  repeated machine_discovery.Gpu gpus = 1;
}

enum MachineHardwareInfoUpdateType {
  Gpus = 0;
}

message ManagedHostNetworkConfigRequest {
  common.MachineId dpu_machine_id = 1;
}

message ManagedHostNetworkConfigResponse {
  reserved 1; // previously is_production_mode

  // ASN and DHCP servers are not versioned, they are fixed on process start

  // ASN
  uint32 asn = 2;
  // DHCP servers that the host DHCP requests should be relayed to
  repeated string dhcp_servers = 3;

  // "" when on admin network, "vxlan48" otherwise.
  // vxlan48 is special HBN single vxlan device. It handles networking between machines on the
  // same subnet. It handles the encapsulation into VXLAN and VNI for cross-host comms.
  // VNI device is not versioned
  string vni_device = 4;

  ManagedHostNetworkConfig managed_host_config = 5;
  string managed_host_config_version = 6;

  bool use_admin_network = 7;
  FlatInterfaceConfig admin_interface = 8;

  repeated FlatInterfaceConfig tenant_interfaces = 9;
  // Blank if on the admin network, matches DB instances.network_config if there's a tenant
  string instance_network_config_version = 10;
  optional common.InstanceId instance_id = 11;

  // Both None if on the admin network
  optional VpcVirtualizationType network_virtualization_type = 12;
  optional uint32 vpc_vni = 13;

  // IP addresses of the L2VPN route servers
  repeated string route_servers = 14;

  // Remote ID. Used by DPU to update host's DHCP request with option 82.
  string remote_id = 15;

  // IPv4 prefixes to be denied in the DPU ACL rules.
  // This is an old field that was hijacked to hold
  // a combination of site_fabric_prefixes _and_ the
  // actual deny_prefixes.  We need to keep populating it
  // to keep older agents happy, but it should eventually go
  // away.
  repeated string deprecated_deny_prefixes = 16;

  // Network monitor pinger type
  optional string dpu_network_pinger_type = 17;

  // IPv4 prefixes to be denied in the DPU ACL rules.
  repeated string deny_prefixes = 18;

  // List of IPv4 prefixes (in CIDR notation) that are assigned for tenant
  // use within this site.
  repeated string site_fabric_prefixes = 19;

  // Level of VPC isolation to apply
  VpcIsolationBehaviorType vpc_isolation_behavior = 20;

  // Whether stateful ACLs are possible and the DPU
  // should perform any extra config to prepare
  // for them.
  bool stateful_acls_enabled = 21;

  // Enable forge DHCP on HBN.
  // Deprecated: It is always enabled now.
  bool enable_dhcp = 100;

  // Host primary interface id
  optional string host_interface_id = 102;

  // temporary flag for telling a DPU how many links it needs to have up to be considered healthy.
  // if not set, all links must be up.
  optional uint32 min_dpu_functioning_links = 103;

  // Is it a primary DPU
  bool is_primary_dpu = 104;

  // Is multidpu feature enabled.
  reserved 105;

  // internet_l3_vni is the GNI-supplied VNI to use to allow
  // VPCs in a given site to get out to the internet. If unset,
  // VPCs in the site will not be configured to get out to
  // the Internet.
  optional uint32 internet_l3_vni = 106;

  optional Instance instance = 107;

  // The GNI-provided ASN of datacenter.
  uint32 datacenter_asn = 108;

  // GNI will import a common route-target for internal
  // tenant routes, reducing the coordination needed
  // between forge and GNI.  We'll double-tag our
  // internal tenant routes with this tag.
  optional common.RouteTarget common_internal_route_target = 109;

  // Additional RTs that we can import if needed for additional services,
  // or to make it easier to handle GNI changes, such as a swap
  // in the default-route RT.
  repeated common.RouteTarget additional_route_target_imports = 110;

  // Rules to be inserted before any other NSG rules.Action
  // This should land in a separate policy on the DPU that is
  // evaluated before any user-defined rules but after deny_prefixes.
  repeated ResolvedNetworkSecurityGroupRule network_security_policy_overrides = 111;

  // Extension services that should be deployed on this DPU
  repeated ManagedHostDpuExtensionServiceConfig dpu_extension_services = 112;

  // All config related to traffic interception on
  // the DPU: intermediate bridging, additional VTEPs, etc.
  optional TrafficInterceptConfig traffic_intercept_config = 113;

  // Route imports and tagging details for exports
  // used by FNN configs.
  // NOTE: This will replace internet_l3_vni and common_internal_route_target but could allow
  //       common_internal_route_target to be renamed/repurposed as a site-level RT.
  //       to become a site-level common route target.
  //       This does _not_ replace additional_route_target_imports, which are global
  //       imports
  optional RoutingProfile routing_profile = 114;

  // List of aggregate IPv4 prefixes (in CIDR notation) that contain prefixes assigned
  // to tenants so that they themselves can announce to the DPU.  E.g., BYOIP
  repeated string  anycast_site_prefixes = 115;

  // An ASN allocated for tenants to use
  // when they peer with the DPU.
  // If configured, the DPU will expect the host
  // to peer with this ASN.  If left unset
  // remote-as external will be used, allowing
  // any ASN.
  optional uint32 tenant_host_asn = 116;

  // Due to limitations in Cumulus Linux route-leaking,
  // some sites may require all VRFs to use the same VNI.
  // Isolation is still possible via ACLs, and route-imports
  // will still use the dynamically allocated VNI for deriving
  // route-targets.
  optional uint32 site_global_vpc_vni = 117;
}

message TrafficInterceptConfig {
  // Optional IP to be used for a VTEP for an additional
  // overlay network.  Initial use-case is catalyst VMaaS's
  // GENEVE overlay.
  optional string additional_overlay_vtep_ip = 1;

  // Internal DPU bridging config VMaaS support
  optional TrafficInterceptBridging bridging = 2;

  // Prefixes expected to be publicly routable and used
  // by VMaaS for internet gateways.
  repeated string public_prefixes            = 3;
}


message TrafficInterceptBridging {
  // Prefix to be used for assigning gateway IPs
  // to bridges used for VMaaS routing within the DPU.
  string internal_bridge_routing_prefix  = 1;

  // Name of the bridge acting as the last hop before the PF
  // on the host.
  string host_intercept_bridge_name      = 2;

  // Name of the bridge acting as the gateway for packets
  // leaving VMaaS pods and destined for the outside.
  // (E.g., internet or pods on other hosts)
  string vf_intercept_bridge_name        = 3;

  // The name of the patch-port on the intercept bridge side
  // that connects to the host_intercept_bridge.
  string host_intercept_bridge_port      = 4;

  // Name of the patch-port on the intercept bridge side
  // of the vf_intercept_bridge that connects to the HBN pod
  // via br-hbn.
  string vf_intercept_bridge_port        = 5;

  // Name of SF used for routing VMaaS VF traffic into
  // the HBN pod.
  string vf_intercept_bridge_sf          = 6;
}

message ManagedHostDpuExtensionServiceConfig {
  string service_id = 1;
  string version = 2;
  string name = 3;
  optional string removed = 4; // Signals that the service was removed from instance config and needs to be terminated
  DpuExtensionServiceType service_type = 5;
  string data = 6;
  optional DpuExtensionServiceCredential credential = 7;
  optional DpuExtensionServiceObservability observability = 8;
}

message ManagedHostQuarantineState {
  ManagedHostQuarantineMode mode = 1;
  optional string reason = 2;
}

enum ManagedHostQuarantineMode {
  BLOCK_ALL_TRAFFIC = 0;
  // other modes may come later
}

enum VpcIsolationBehaviorType {
  VPC_ISOLATION_INVALID = 0;
  VPC_ISOLATION_OPEN    = 1;
  VPC_ISOLATION_MUTUAL  = 2;
}

message GetManagedHostQuarantineStateRequest {
  common.MachineId machine_id = 1;
}

message GetManagedHostQuarantineStateResponse {
  optional ManagedHostQuarantineState quarantine_state = 1;
}

message SetManagedHostQuarantineStateRequest {
  common.MachineId machine_id = 1;
  ManagedHostQuarantineState quarantine_state = 2;
}

message SetManagedHostQuarantineStateResponse {
  optional ManagedHostQuarantineState prior_quarantine_state = 1;
}

message ClearManagedHostQuarantineStateRequest {
  common.MachineId machine_id = 1;
}

message ClearManagedHostQuarantineStateResponse {
  optional ManagedHostQuarantineState prior_quarantine_state = 1;
}

// Network configuration for a managed host (host + DPU pair) managed by Forge
message ManagedHostNetworkConfig {
  // DPU loopback IP
  string loopback_ip = 1;
  optional ManagedHostQuarantineState quarantine_state = 2;
}

message FlatInterfaceConfig {
  InterfaceFunctionType function_type = 1;
  // aka circuit_id
  uint32 vlan_id = 2;

  // vni is the vxlan id (aka the L2VNI), which is the unique
  // VNI assigned per network segment. In an FNN-L3 setup, this
  // is used as the base of a DPU-specific VNI, where each DPU
  // gets its own unique L2VNI per segment, which is accomplished
  // by making <vni><dpi-id>.
  //
  // TODO(chet): A VNI is actually a 24 bit integer, which is
  // fine, because this allows for more than that, but we should
  // probably be checking somewhere that the VNI we're passing down
  // isn't going to overflow once it gets to HBN.
  uint32 vni = 3;

  // in CIDR notation
  string gateway = 4;
  // host admin ip for admin network, host ip for tenant
  string ip = 5;
  // The interface-specific prefix allocation (which may be a /32 for
  // just the host IP, or a larger allocation, like a /30, for FNN). The
  // `ip` as configured above will be contained within the `interface_prefix`
  // provided here, and the `interface_prefix` will be contained within
  // the `prefix` below (field 8).
  string interface_prefix = 11;
  // If the interface is defined as a virtual function (associated
  // `function_type == InterfaceFunctionType::VIRTUAL_FUNCTION`,
  // then this value is set and specifies the virtual function ID that is configured
  // for this network interface.
  optional uint32 virtual_function_id = 6;
  // A list of IPv4 prefixes that belong to this VPC. Note this may contain
  // the prefix from the network segment this interface is attached to (which
  // could be independently derived from the `gateway` field).
  repeated string vpc_prefixes = 7;
  // Prefix for the network segment this interface lives in,
  // which is what is referred to as a subnet in the UI. This
  // is not to be confused with the instance_prefix, which is
  // an allocation out of THIS prefix, which is being assingned
  // to a given interface.
  //
  // TODO(chet): This is going to eventually be refactored as part
  // of changes related to Carbide IP Prefix Management, where we
  // ultimately do want a DPU-specific prefix allocation to be its
  // own prefix entry in the `network_prefixes` table (or something
  // similar).
  string prefix = 8;
  // FQDN
  string fqdn = 9;
  // boot_url
  optional string booturl = 10;

  // vpc_vni is the L3VNI used for FNN-enabled VPCs. The VNI
  // itself comes from a pool of VNIs allocated to us by GNI,
  // is then configured as a resource pool per site (the vpc-vni
  // pool), and is done in such a way that each VNI is globally
  // unique per VPC.
  uint32 vpc_vni = 12;

  // svi_ip (also known as the gateway IP), is the local DPU-hosted
  // gateway to be used by an instance in an FNN-L3 configuration (as
  // in the host actually sets this IP as its gateway). This is the 3rd
  // IP allocated from the /30, where the /30 is broken into two /31s,
  // and the SVI IP is the first IP in the second /31.
  optional string svi_ip = 13;

  // tenant_vrf_loopback_ip is an administrative IP assigned from
  // the FNN L3 allocated /30 DPU prefix. The tenant is not expected
  // to be able to access this IP; it is intended for monitoring
  // and debugging by operators.
  optional string tenant_vrf_loopback_ip = 14;

  // Is this interface using L2 or L3.
  bool is_l2_segment = 15;

  repeated string vpc_peer_prefixes = 16;
  repeated uint32 vpc_peer_vnis = 17;

  // MTU size
  optional uint32 mtu = 18;

  // The details of the network security group associated with
  // either the instance or its parent VPC.
  // Currently, source would either be INSTANCE or VPC.
  // We only expect to actually support VPC and instance-level
  // for the foreseeable future, but an instance with multiple
  // DPUs that each have a network segment that leads back to
  // a different VPC would need to track their NSG details
  // separately.
  optional FlatInterfaceNetworkSecurityGroupConfig network_security_group = 107;

  // A UUID used to associate a network status with an interface config.
  optional common.UUID internal_uuid = 108;
}

message FlatInterfaceNetworkSecurityGroupConfig {
  string id                                       = 1;
  string version                                  = 2;
  NetworkSecurityGroupSource source               = 3;
  repeated ResolvedNetworkSecurityGroupRule rules = 4;
  bool stateful_egress                            = 5;
}

message ManagedHostNetworkStatusRequest {
}
message ManagedHostNetworkStatusResponse {
  repeated DpuNetworkStatus all = 1;
}

message DpuAgentUpgradeCheckRequest {
  string machine_id = 1;
  string current_agent_version = 2;
  google.protobuf.Timestamp binary_mtime = 3;
  string binary_sha = 4;
}

message DpuAgentUpgradeCheckResponse {
  bool should_upgrade = 1;
  string package_version = 2; // Update to this version of the .deb package
  string server_version = 3;
}

message DpuAgentUpgradePolicyRequest {
  optional AgentUpgradePolicy new_policy = 1;
}

enum AgentUpgradePolicy {
  OFF = 0;
  UP_ONLY = 1;
  UP_DOWN = 2;
}

message DpuAgentUpgradePolicyResponse {
  // The policy in effect right now
  AgentUpgradePolicy active_policy = 1;
  // Did we just change it because of a user request?
  bool did_change = 2;
}

message AdminForceDeleteMachineRequest {
  // UUID, IP address, host name or MAC address of either the host or DPU to force delete
  string host_query = 1;

  // Should we delete oob_net0 and host interfaces?
  bool delete_interfaces = 2;

  // Should we delete BMC interfaces? Please note, this will depend on if BMC interfaces
  // are associated with machine.
  bool delete_bmc_interfaces = 3;

  // Should we delete the BMC credentials? Please note, this will depend on if site explore configured
  // credentials for this machine.
  bool delete_bmc_credentials = 4;
}

// Response to AdminForceDeleteMachine call
// Describes which resources have been released
message AdminForceDeleteMachineResponse {
  bool all_done = 1;

  string managed_host_machine_id = 11;
  string managed_host_machine_interface_id = 12;
  // Deprecated: Use dpu_machine_ids
  string dpu_machine_id = 13;
  // Deprecated: Use dpu_machine_interface_ids
  string dpu_machine_interface_id = 14;
  string instance_id = 15;

  string managed_host_bmc_ip = 21;
  string dpu_bmc_ip = 22;

  reserved 31, 32, 33, 34; // Had been related to the deprecated forge-vpc service

  // How many interfaces have been unregistered from UFM
  uint32 ufm_unregistrations = 35;
  // UFM unregistrations have been started, but could not be finished
  bool ufm_unregistration_pending = 36;

  // The Machines lockdown state before it was attempted to unlock the Machine
  string initial_lockdown_state = 41;
  // Whether the Machine had been unlocked as part of this action
  bool machine_unlocked = 42;

  // Whether the machine interfaces are deleted.
  bool host_interfaces_deleted = 43;
  bool dpu_interfaces_deleted = 44;

  // Whether the BMC interfaces are found.
  bool host_bmc_interface_associated = 45;
  bool dpu_bmc_interface_associated = 46;

  // Whether the BMC interfaces are deleted.
  bool host_bmc_interface_deleted = 47;
  bool dpu_bmc_interface_deleted = 48;

  repeated string dpu_machine_ids = 49;
  repeated string dpu_machine_interface_ids = 50;

}

message DisableSecureBootResponse {
}

message LockdownRequest {
  optional BmcEndpointRequest bmc_endpoint_request = 1;
  optional common.MachineId machine_id = 2;
  optional LockdownAction action = 3;
}

enum LockdownAction {
  ENABLE = 0;
  DISABLE = 1;
}

message LockdownResponse {
}

message LockdownStatusRequest {
  optional BmcEndpointRequest bmc_endpoint_request = 1;
  optional common.MachineId machine_id = 2;
}

message MachineSetupStatusRequest {
  optional BmcEndpointRequest bmc_endpoint_request = 1;
  optional string machine_id = 2;
}

message MachineSetupRequest {
  optional BmcEndpointRequest bmc_endpoint_request = 1;
  optional string machine_id = 2;
  optional string boot_interface_mac = 3;
}

message MachineSetupResponse {
}

message SetDpuFirstBootOrderRequest {
  optional BmcEndpointRequest bmc_endpoint_request = 1;
  optional string machine_id = 2;
  optional string boot_interface_mac = 3;
}

message SetDpuFirstBootOrderResponse {
}

// Must provide either machine_id or ip/mac pair
message AdminRebootRequest {
  optional BmcEndpointRequest bmc_endpoint_request = 1;
  optional string machine_id = 2;
}

message AdminRebootResponse {
}

// Must provide either machine_id or ip/mac pair
message AdminBmcResetRequest {
  optional BmcEndpointRequest bmc_endpoint_request = 1;
  optional string machine_id = 2;
  bool use_ipmitool = 3;
}

message AdminBmcResetResponse {
}

message EnableInfiniteBootRequest{
  optional BmcEndpointRequest bmc_endpoint_request = 1;
  optional string machine_id = 2;
}

message EnableInfiniteBootResponse {
}

message IsInfiniteBootEnabledRequest{
  optional BmcEndpointRequest bmc_endpoint_request = 1;
  optional string machine_id = 2;
}

message IsInfiniteBootEnabledResponse {
  optional bool is_enabled = 1;
}

enum BMCRequestType {
  IPMI = 0;
  REDFISH = 1;
}

message BMCMetaDataGetRequest {
  // Machine ID for which credentials are fetched
  common.MachineId machine_id = 1;
  UserRoles role = 2;
  BMCRequestType request_type = 3;
  // As an alternative to the Machine ID, the BMC IP can be directly specified
  optional BmcEndpointRequest bmc_endpoint_request = 4;
}

message BMCMetaDataGetResponse {
  string ip = 1;
  string user = 2;
  string password = 3;
  string mac = 4;
  optional uint32 port = 5;
  optional uint32 ssh_port = 6;
  optional uint32 ipmi_port = 7;
}

message MachineCredentialsUpdateRequest {
  enum CredentialPurpose {
    HBN = 0;
    LOGIN_USER = 1;
    BMC = 2;
  }

  message Credentials {
    string user = 1;
    string password = 2;
    CredentialPurpose credential_purpose = 3;
  }

  common.MachineId machine_id = 4;
  repeated Credentials credentials = 5;
  optional string mac_address = 6;
}

message MachineCredentialsUpdateResponse {
}

message ForgeAgentControlRequest {
  common.MachineId machine_id = 1;
}

message ForgeAgentControlResponse {
  enum Action {
    NOOP = 0; // No operation. Do nothing
    RESET = 1; // Wipe the machine, prepare for next tenant
    DISCOVERY = 2; // Run full discovery
    REBUILD = 3; // Future thingy
    RETRY = 4; // Machine needs more time to come in proper state. Retry again.
    MEASURE = 5; // Machine needs to send measurements for attestation.
    LOGERROR = 6; // Log error.
    MACHINE_VALIDATION = 7; // Machine validation.
    MLX_ACTION = 8; // MlxAction for DPA NICs
  }
  Action action = 1;

  message ForgeAgentControlExtraInfo {
    message KeyValuePair {
      string key = 1;
      string value = 2;
    }
    repeated KeyValuePair pair = 1;
  }

  optional ForgeAgentControlExtraInfo data = 2;
}

message MachineDiscoveryInfo {
  common.MachineInterfaceId machine_interface_id = 1;
  oneof discovery_data {
    machine_discovery.DiscoveryInfo info = 2;
  }
  bool create_machine = 3;
}

message MachineDiscoveryCompletedRequest {
  common.MachineId machine_id = 1;
  reserved 2; // Discovery completed no longer returns an error
}

message MachineCleanupInfo {
  enum CleanupResult {
    OK = 0;
    ERROR = 1;
  }
  message CleanupStepResult {
    CleanupResult result = 1;
    // If the result was an error, this can contain the associate error message
    string message = 2;
  }

  common.MachineId machine_id = 1;

  // NVMe Cleanup Result
  CleanupStepResult nvme = 2;
  // RAM cleanup result
  CleanupStepResult ram = 3;
  // EFI variable MemoryOverwriteRequestControl-e20939be-32d4-41be-a150-897f85d49829 must be set to 1
  CleanupStepResult mem_overwrite = 4;
  // Reset IB devices
  CleanupStepResult ib = 5;

  CleanupResult result = 11;
}

message MachineCertificate {
  bytes public_key = 1;
  bytes private_key = 2;
  bytes issuing_ca = 3;
}

message MachineCertificateRenewRequest {
} // The certificate to renew is delivered via the TLS channel.
message MachineCertificateResult {
  // the renewed certificate for the client that
  MachineCertificate machine_certificate = 1;
}

message MachineDiscoveryResult {
  // This is returned to the discovery client from the API. Lets try not to put much in here unless we need it.
  common.MachineId machine_id = 1;
  // This is returned to the discovery client so that it can use the embedded certificate to authenticate to the api for further communications.
  MachineCertificate machine_certificate = 2;
  // if attestation is enabled, this challenge will allow to bind attestation key to a particular TPM via its EK
  AttestKeyBindChallenge attest_key_challenge = 3;
  // Interface id
  common.MachineInterfaceId machine_interface_id = 4;
}

message MachineDiscoveryCompletedResponse {
}

message MachineCleanupResult {
  // This is returned to the discovery client from the API. Lets try not to put much in here unless we need it.
}

message ForgeScoutErrorReport {
  // Machine that encountered the error
  // This might be null if the MachineId could not be resolved
  common.MachineId machine_id = 1;
  // Interface ID of the Machine that encountered the error
  common.MachineInterfaceId machine_interface_id = 2;
  // Error report
  string error = 3;
}

message ForgeScoutErrorReportResult {
}

message PxeInstructionRequest {
  MachineArchitecture arch = 1;
  common.MachineInterfaceId interface_id = 2;
  optional string product = 3;
}

message PxeInstructions {
  string pxe_script = 1;
}

message CloudInitDiscoveryInstructions {
  MachineInterface machine_interface = 1;
  PxeDomain domain = 2;
  optional string hbn_reps = 3;
  optional string hbn_sfs = 4;
  optional string vf_intercept_bridge_name = 5;
  optional string host_intercept_bridge_name = 6;
  // The <vf_intercept_bridge_name> side of the SF representor that connects the HBN pod to br-hbn.
  // This will be the side owned by the <vf_intercept_bridge_name> bridge
  optional string vf_intercept_bridge_port   = 7;

  // The <host_intercept_bridge_name> side of the SF representor that connects the HBN pod to br-hbn.
  // This will be the side owned by the <host_intercept_bridge_name> bridge.
  optional string host_intercept_bridge_port = 8;

  // The representor that will plug into the HBN container to connect it to br-hbn
  // to open connectivity between all the VFs.
  optional string vf_intercept_bridge_sf = 9;
}

message CloudInitMetaData {
  string instance_id = 1;
  string cloud_name = 2;
  string platform = 3;
}

message CloudInitInstructionsRequest {
  string ip = 1;
}

message CloudInitInstructions {
  optional string custom_cloud_init = 1;
  optional CloudInitDiscoveryInstructions discovery_instructions = 2;
  optional CloudInitMetaData metadata = 3;
}

// Specifies whether a network interface is physical network function (PF)
// or a virtual network function
enum InterfaceFunctionType {
  PHYSICAL = 0;
  VIRTUAL = 1;
}

// What forge-dpu-agent reports. Will grow over time.
message DpuNetworkStatus {
  common.MachineId dpu_machine_id = 1;
  google.protobuf.Timestamp observed_at = 2;
  // Legacy mechanism to indicate DPU health.
  reserved 3; // Was NetworkHealth health = 3; - // Replaced by the `dpu_health` field
  optional string network_config_version = 4;
  // If an instance is configured, this field references the version of the networking
  // configuration that is applied on the instance
  optional string instance_network_config_version = 5;
  repeated InstanceInterfaceStatusObservation interfaces = 6;
  optional string network_config_error = 7;
  optional common.InstanceId instance_id = 8;
  optional string dpu_agent_version = 9;
  optional int64 client_certificate_expiry_unix_epoch_secs = 10;
  health.HealthReport dpu_health = 11;
  // The version of the instance configuration that had been applied by forge-network-config
  // This version number tracks versioning OS details, tags, etc
  // It is different than instance_network_config_version, which only tracks networking details
  optional string instance_config_version = 12;
  repeated FabricInterfaceData fabric_interfaces = 13;
  repeated LastDhcpRequest last_dhcp_requests = 14;
  // Extension service status reported by DPU
  optional string dpu_extension_service_version = 15;
  repeated DpuExtensionServiceStatusObservation dpu_extension_services = 16;
}

message LastDhcpRequest {
  common.MachineInterfaceId host_interface_id = 1;
  string timestamp = 2;
}

// DPU extension service status
message DpuExtensionServiceStatusObservation {
  string service_id = 1;
  DpuExtensionServiceType service_type = 2;
  string service_name = 3;
  string version = 4;
  optional string removed = 5; // Signals that this service was removed from instance config and is terminating
  DpuExtensionServiceDeploymentStatus state = 6;
  repeated DpuExtensionServiceComponent components = 7;
  string message = 8;
}

message DpuExtensionServiceComponent {
  string name = 1;
  string version = 2;
  string url = 3;
  string status = 4;
}

message HardwareHealthReport {
  common.MachineId machine_id = 1;
  health.HealthReport report = 2;
}

message OptionalHealthReport {
  optional health.HealthReport report = 1;
}

enum OverrideMode {
  // Keep the existing health reports, and merge them with this health report.
  // If 2 reports report the same failures based on `id`s on `target`s
  // - the classifications of both alerts will be merged
  // - messages of both alerts will be concatenated
  // - the `in_alert_since` timestamp of the original alert will be retained
  Merge = 0;
  // Replace the health report in the system with this new health report
  Replace = 1;
}

message HealthReportOverride {
  health.HealthReport report = 1;
  OverrideMode mode = 2;
}

message InsertHealthReportOverrideRequest {
  common.MachineId machine_id = 1;
  HealthReportOverride override = 2;
}

// Request to insert a health report override for a Rack.
// Same as InsertHealthReportOverrideRequest but with rack_id instead of machine_id.
message InsertRackHealthReportOverrideRequest {
  common.RackId rack_id = 1;
  HealthReportOverride override = 2;
}

// Request to remove a health report override for a Rack.
// Same as RemoveHealthReportOverrideRequest but with rack_id instead of machine_id.
message RemoveRackHealthReportOverrideRequest {
  common.RackId rack_id = 1;
  string source = 2;
}

// Request to list health report overrides for a Rack.
message ListRackHealthReportOverridesRequest {
  optional common.RackId rack_id = 1;
}

message ListHealthReportOverrideResponse {
  repeated HealthReportOverride overrides = 1;
}

message RemoveHealthReportOverrideRequest {
  common.MachineId machine_id = 1;
  string source = 2;
}

// Observed status of a single network interface of an instance
message InstanceInterfaceStatusObservation {
  // Whether the interface is a physical or virtual function
  // In the case of a virtual function the associated
  // `virtual_function_id` describes the ID of the interface
  InterfaceFunctionType function_type = 1;

  // If the interface is defined as a virtual function (associated
  // `function_type == InterfaceFunctionType::VIRTUAL_FUNCTION`,
  // then this value is set and specifies the virtual function ID that is configured
  // for this network interface.
  optional uint32 virtual_function_id = 2;

  // The MAC address which has been assigned to this interface
  // The list will be empty if interface configuration hasn't been completed
  // and therefore the address is unknown.
  optional string mac_address = 3;

  // The list of IP addresses that had been assigned to this interface,
  // based on the requested subnet.
  // The list will be empty if interface configuration hasn't been completed
  repeated string addresses = 4;

  // The list of gateways, in CIDR notation, one for each address in `addresses`.
  repeated string gateways = 5;

  // The list of IP prefixes that have been assigned to this interface
  // out of the requested subnet (where the prefix allocated to the interface
  // may be a /30 in the case of FNN, or just a /32 in the case of ETV).
  //
  // This is similar to `gateways`, in that there is one `prefix` for each
  // address in `addresses`.
  repeated string prefixes = 6;

  // The NSG details for the observed NSG of the interface
  NetworkSecurityGroupStatus network_security_group  = 7;

  // an internal uuid that identifies the interface this status is for
  optional common.UUID internal_uuid = 8;

}

// Describes observational data for a network interface associated with a
// network fabric (e.g. a DPU's uplinks to the underlay network).
message FabricInterfaceData {
  string interface_name = 1;

  LinkData link_data = 2;
}

// Link attributes from rtnetlink or equivalent.
message LinkData {
  optional string link_type = 1;
  optional string state = 2;
  optional bool carrier_up = 3;
  optional uint32 mtu = 4;
  optional uint32 carrier_up_count = 5;
  optional uint32 carrier_down_count = 6;
}

message Tenant {
  string organization_id = 1;
  Metadata metadata = 2;
  // this string is used to verify that the client has the most updated "view" of a keyset when attempting to modify it
  string version = 3;
  optional RoutingProfileType routing_profile_type = 4;
}

message CreateTenantRequest {
  // this organization ID must be globally unique
  string organization_id = 1;
  Metadata metadata = 2;
  optional RoutingProfileType routing_profile_type = 3;
}
message CreateTenantResponse {
  Tenant tenant = 1;
}

message UpdateTenantRequest {
  string organization_id = 1;
  Metadata metadata = 2;

  // if this field is set and non-empty, the request will only update the tenant if the version matches the server's view,
  // otherwise it will return a concurrency related error.
  optional string if_version_match = 3;

  // Updating will only be allowed if the tenant has no active VPCs
  optional RoutingProfileType routing_profile_type = 4;
}
message UpdateTenantResponse {
  // the updated tenant after modification
  Tenant tenant = 1;
}

message FindTenantRequest {
  string tenant_organization_id = 1;
}
message FindTenantResponse {
  Tenant tenant = 1;
}

message TenantKeysetIdentifier {
  // the organization_id of the associated tenant, required to be non-null and globally unique
  string organization_id = 1;
  // the id of the key, provided by the tenant.  Must be unique within the tenant's organization.
  // TODO: update this document once we have a clearer idea of the charset restrictions for this provided identifier.
  string keyset_id = 2;
}

message TenantPublicKey {
  string public_key = 1;
  optional string comment = 2;
}

message TenantKeysetContent {
  repeated TenantPublicKey public_keys = 1;
}

message TenantKeyset {
  TenantKeysetIdentifier keyset_identifier = 1;
  TenantKeysetContent keyset_content = 2;
  // this version will be used to determine if a client has the most updated "view" of a tenant when attempting to modify it
  string version = 3;
}

message CreateTenantKeysetRequest {
  TenantKeysetIdentifier keyset_identifier = 1;
  // it is allowed for the provided request to contain no keys, which will reserve the identifier as an empty set.
  TenantKeysetContent keyset_content = 2;
  // The new version that should be stored for the keyset. The Forge site controller
  // will store this version field as the new version for the data. It will not
  // assign a version on its own.
  string version = 3;
}
message CreateTenantKeysetResponse {
  TenantKeyset keyset = 1;
}

message TenantKeySetList {
  repeated TenantKeyset keyset = 1;
}

message UpdateTenantKeysetRequest {
  // this request will update the existing keyset provided the identifiers match
  TenantKeysetIdentifier keyset_identifier = 1;
  TenantKeysetContent keyset_content = 2;

  // The new version that should be stored for the keyset. The Forge site controller
  // will store this version field as the new version for the data. It will not
  // assign a version on its own.
  string version = 3;

  // if this field is set and non-empty, the request will only update the tenant if the version matches the server's view,
  // otherwise it will return a concurrency related error.
  optional string if_version_match = 4;
}
message UpdateTenantKeysetResponse {
  // Since the update request overwrites the whole keyset, the caller of the API
  // already knows the data that will be stored after a successful update.
  // Therefore this response does not need to carry any data.
}

message DeleteTenantKeysetRequest {
  TenantKeysetIdentifier keyset_identifier = 1;
}
message DeleteTenantKeysetResponse {
}

message TenantKeysetSearchFilter {
  optional string tenant_org_id = 1;
}

message TenantKeysetIdList {
  repeated TenantKeysetIdentifier keyset_ids = 1;
}

message TenantKeysetsByIdsRequest {
  repeated TenantKeysetIdentifier keyset_ids = 1;
  bool include_key_data = 2;
}

// the tenantPublicKey will be checked against the following lists for permission to access the instance:
// 1) the instance's keysets.
// 2) the vpc's keyset.
// 3) the tenant's keyset.
// if the key is present in one of those lists, the request will be granted permission to access the instance.
message ValidateTenantPublicKeyRequest {
  string instance_id = 1;
  string tenant_public_key = 2;
}
// the status of the response will be in the grpc Status object, along with any associated Errors.
message ValidateTenantPublicKeyResponse {
}

message ListResourcePoolsRequest {
}
message ResourcePools {
  repeated ResourcePool pools = 1;
}

message ResourcePool {
  string name = 1;
  string min = 2;
  string max = 3;
  uint64 total = 4;
  uint64 allocated = 5;
}

message GrowResourcePoolRequest {
  // TOML definition of resized pools
  string text = 1;
}

message GrowResourcePoolResponse {
}

message Range {
  string start = 1;
  string end = 2;
}

enum ResourcePoolType {
  Integer = 0;
  Ipv4 = 1;
}

message MigrateVpcVniResponse {
  uint32 updated_count = 1;
  uint32 total_vpc_count = 2;
}

enum MaintenanceOperation {
  Enable = 0;
  Disable = 1;
}

message MaintenanceRequest {
  MaintenanceOperation operation = 1;
  // Managed host ID
  common.MachineId host_id = 2;
  // For Enable: The ticket tracker URL.
  optional string reference = 3;
}

message SetDynamicConfigRequest {
  ConfigSetting setting = 1;
  string value = 2;
  optional string expiry = 3;
}

enum ConfigSetting {
  LOG_FILTER = 0;
  CREATE_MACHINES = 1;
  BMC_PROXY = 2;
  TRACING_ENABLED = 3;
}

message FindIpAddressRequest {
  string ip = 1;
}

message FindIpAddressResponse {
  repeated IpAddressMatch matches = 1;
  repeated string errors = 2;
}

message IdentifyUuidRequest {
  common.UUID uuid = 1;
}

message IdentifyUuidResponse {
  common.UUID uuid = 1;
  UuidType object_type = 2;
}

// See IpType for protobuf's C++ scoping rule explanation
enum UuidType {
  UuidTypeNetworkSegment = 0;
  UuidTypeInstance = 1;
  UuidTypeMachineInterface = 2;
  UuidTypeVpc = 3;
  UuidTypeDomain = 4;
  UuidTypeDpaInterfaceId = 5;
}

message IdentifyMacRequest {
  string mac_address = 1;
}

message IdentifyMacResponse {
  string mac_address = 1;
  string primary_key = 2;
  MacOwner object_type = 3;
}

enum MacOwner {
  MacOwnerMachineInterface = 0;
  MacOwnerExploredEndpoint = 1;
  MacOwnerExpectedMachine = 2;
  MacOwnerDpaInterface = 3;
}

message IdentifySerialRequest {
  string serial_number = 1;
  // If true, only return exact matches.
  bool exact = 2;
}

message IdentifySerialResponse {
  string serial_number = 1;
  common.MachineId machine_id = 2;
}

enum UpdateInitiator {
  AdminCli = 0;
  Automatic = 1;
}

message DpuReprovisioningRequest {
  enum Mode {
    Set = 0;
    Clear = 1;
    Restart = 2;
  }
  // DEPRECATED, use machine id field.
  common.MachineId dpu_id = 1;
  Mode mode = 2;
  UpdateInitiator initiator = 3;
  bool update_firmware = 4;

  common.MachineId machine_id = 5;
}

message DpuReprovisioningListRequest {
}

message DpuReprovisioningListResponse {
  message DpuReprovisioningListItem {
    common.MachineId id = 1; // Dpu Machine ID
    string state = 2; // ManagedHost state
    string initiator = 3; // Who requested this reprovisioning.
    google.protobuf.Timestamp requested_at = 4; // When reprovisioning was requested.
    bool update_firmware = 5;
    optional google.protobuf.Timestamp initiated_at = 6;  // When reprovisioning is started.
    bool user_approval_received = 7; // User approval received or not if needed
  }
  repeated DpuReprovisioningListItem dpus = 1;
}

message HostReprovisioningRequest {
  enum Mode {
    Set = 0;
    Clear = 1;
  }
  common.MachineId machine_id = 1;
  Mode mode = 2;
  UpdateInitiator initiator = 3;
}

message HostReprovisioningListRequest {
}

message HostReprovisioningListResponse {
  message HostReprovisioningListItem {
    common.MachineId id = 1; // Machine ID
    string state = 2; // ManagedHost state
    string initiator = 3; // Who requested this reprovisioning.
    google.protobuf.Timestamp requested_at = 4; // When reprovisioning was requested.
    optional google.protobuf.Timestamp initiated_at = 5;  // When reprovisioning is started.
    bool user_approval_received = 6; // User approval received or not if needed
  }
  repeated HostReprovisioningListItem hosts = 1;
}

message DpuInfo {
  string id = 1;
  string loopback_ip = 2;
}

message GetDpuInfoListRequest {

}

message GetDpuInfoListResponse {
  repeated DpuInfo dpu_list = 1;
}

message IpAddressMatch {
  IpType ip_type = 1;
  optional string owner_id = 2; // resource pool name, instance id, machine id, etc
  string message = 3; // Display to end user. Usually has more details than just type/owner_id.
}

// The things `forge-admin-cli ip find` searches.
//
// Why the IpType prefix on everything, you ask? Because:
// > Note that enum values use C++ scoping rules, meaning that enum values are siblings of their
// > type, not children of it.
// Yeah I'm surprised too.
enum IpType {
  IpTypeStaticDataDhcpServer = 0;
  // DEPRECATED: IpTypeStaticDataRouteServer is deprecated in favor
  // of IpTypeRouteServerFromConfigFile and IpTypeRouteServerFromAdminApi.
  IpTypeStaticDataRouteServer = 1;
  IpTypeResourcePool = 2;
  IpTypeInstanceAddress = 3;
  IpTypeMachineAddress = 4;
  IpTypeBmcIp = 5;
  IpTypeLoopbackIp = 6;
  IpTypeNetworkSegment = 7;
  IpTypeExploredEndpoint = 8;
  // IpTypeRouteServerFromConfigFile are IPs from the route_servers
  // table that have been synced via the carbide-api config file
  // at startup (see setup.rs and db_init.rs). Their DB records
  // specifically say their source type is `config_file`.
  IpTypeRouteServerFromConfigFile = 9;
  // IpTypeRouteServerFromAdminApi are IPs from the route_servers
  // table that have been added via forge-admin-cli calls. Their
  // DB records specifically say their source type is `admin`.
  IpTypeRouteServerFromAdminApi = 10;
  IpTypeDpaInterface = 11;
}

message MachineBootOverride {
  common.MachineInterfaceId machine_interface_id = 1;
  optional string custom_pxe = 2;
  optional string custom_user_data = 3;
}

// A connected device is described by DPU and local port.
message ConnectedDevice {
  common.MachineId id = 1;
  string local_port = 2;
  string remote_port = 3;
  optional string network_device_id = 4;
}

message ConnectedDeviceList {
  repeated ConnectedDevice connected_devices = 1;
}

message BmcIpList {
  repeated string bmc_ips = 1;
}

message BmcIp {
  string bmc_ip = 1;
}

message MacAddressBmcIp {
  string bmc_ip = 1;
  string mac_address = 2;
}

message MachineIdBmcIpPairs {
  repeated MachineIdBmcIp pairs = 1;
}

message MachineIdBmcIp {
  common.MachineId machine_id = 1;
  string bmc_ip = 2;
}

// NetworkDevice and Switch are used interchangeably.
message NetworkDevice {
  string id = 1;
  string name = 2;
  optional string description = 3;
  repeated string mgmt_ip = 4;
  string discovered_via = 5;
  string device_type = 6;

  repeated ConnectedDevice devices = 7;
}

message NetworkTopologyRequest {
  optional string id = 1;
}

message NetworkDeviceIdList {
  repeated string network_device_ids = 1;
}

message NetworkTopologyData {
  repeated NetworkDevice network_devices = 1;
}

message RouteServers {
  // route_servers is just a list of addresses to
  // either add, remove, or replace, for the given
  // source_type.
  repeated string route_servers = 1;
  // RouteServerSourceType targets which source_type
  // to add/remove/replace route server addresses for
  // in the database. By default, it is *assumed* that
  // API calls mean AdminApi (aka "admin_api"). However,
  // we provide this option to allow admin API calls
  // to handle overriding ConfigFile (aka "config_file")
  // sourced entries as well, which is really intended
  // for break-glass types of situations where a bad
  // config rollout may need quick intervention via
  // the admin API to correct (and not wait for a
  // config rollback).
  RouteServerSourceType source_type = 2;
}

message RouteServerEntries {
  repeated RouteServer route_servers = 1;
}

// RouteServer models a RouteServer struct in
// code, which models a route_servers record
// in the database.
message RouteServer {
  string address = 1;
  RouteServerSourceType source_type = 2;
}

// RouteServerSourceType maps to the RouteServerSourceType
// type in the database, where ConfigFile == config_file,
// and AdminApi == admin_api.
enum RouteServerSourceType {
  ConfigFile = 0;
  AdminApi = 1;
}

message SetHostUefiPasswordRequest {
  // Deprecated: use machine_query instead
  common.MachineId host_id = 1;
  // UUID, IP address, hostname or MAC address
  optional string machine_query = 2;
}

message SetHostUefiPasswordResponse {
  optional string job_id = 1;
}

message ClearHostUefiPasswordRequest {
  // Deprecated: use machine_query instead
  common.MachineId host_id = 1;
  // UUID, IP address, hostname or MAC address
  optional string machine_query = 2;
}

message ClearHostUefiPasswordResponse {
  optional string job_id = 1;
}

enum OsImageStatus {
  // default status when entry created
  ImageUninitialized = 0;
  // if a boot volume should be created, this will be set when it is being setup
  ImageInProgress = 1;
  // on any errors
  ImageFailed = 2;
  // usable for AllocateInstance requests
  ImageReady = 3;
  // disabled for further use
  ImageDisabled = 4;
}

message OsImageAttributes {
  // needs to be generated by the caller (cloud) during CreateOsImage call
  common.UUID id = 1;
  string source_url = 2;
  string digest = 3;
  string tenant_organization_id = 4;
  // set this if creating a source volume for creating snapshots
  bool create_volume = 5;
  optional string name = 6;
  optional string description = 7;
  optional string auth_type = 8;
  optional string auth_token = 9;
  optional string rootfs_id = 10;
  optional string rootfs_label = 11;
  // not applicable/not used if create_volume == true
  optional string boot_disk = 12;
  optional uint64 capacity = 13;
  optional string bootfs_id = 14;
  optional string efifs_id = 15;
}

message OsImage {
  OsImageAttributes attributes = 1;
  OsImageStatus status = 2;
  optional string status_message = 3;
  reserved 4;
  optional string created_at = 5;
  optional string modified_at = 6;
}

message ListOsImageRequest {
  optional string tenantOrganizationId = 1; // protolint:disable:this FIELD_NAMES_LOWER_SNAKE_CASE
}

message ListOsImageResponse {
  repeated OsImage images = 1;
}

message DeleteOsImageRequest {
  common.UUID id = 1;
  string tenantOrganizationId = 2; // protolint:disable:this FIELD_NAMES_LOWER_SNAKE_CASE
}

message DeleteOsImageResponse {
}


message ExpectedHostNic {
  string mac_address = 1;
  optional string nic_type = 2;
  optional string fixed_ip = 3;
  optional string fixed_mask = 4;
  optional string fixed_gateway = 5;
}

message ExpectedMachine {
  string bmc_mac_address = 1;
  string bmc_username = 2;
  string bmc_password = 3;
  string chassis_serial_number = 4;
  repeated string fallback_dpu_serial_numbers = 5;
  // Metadata that will automatically get associated with a newly created Machine
  Metadata metadata = 6;
  optional string sku_id =  7;
  // Unique identifier for the expected machine. When omitted, server generates one.
  optional common.UUID id = 8;
  repeated ExpectedHostNic host_nics = 9;
  optional common.RackId rack_id = 10;
  optional bool default_pause_ingestion_and_poweron = 11;
  bool dpf_enabled = 12;
}

message ExpectedMachineRequest {
  string bmc_mac_address = 1;
  // Optional unique identifier for selecting an expected machine.
  // If provided, server will use this to select the record.
  optional common.UUID id = 2;
}

message ExpectedMachineList {
  repeated ExpectedMachine expected_machines = 1;
}

message LinkedExpectedMachineList {
  repeated LinkedExpectedMachine expected_machines = 1;
}

message LinkedExpectedMachine {
  string chassis_serial_number = 1;
  string bmc_mac_address = 2;
  optional string interface_id = 3;
  optional string explored_endpoint_address = 4;
  optional common.MachineId machine_id = 5;
  optional common.UUID expected_machine_id = 6;
}

message BatchExpectedMachineOperationRequest {
  // The list of expected machines to create or update
  ExpectedMachineList expected_machines = 1;
  // Whether to accept partial results (continue processing even if some operations fail)
  bool accept_partial_results = 2;
}

message ExpectedMachineOperationResult {
  // The ID of the ExpectedMachine this result is for
  common.UUID id = 1;
  // Whether the operation succeeded
  bool success = 2;
  // Error message if the operation failed
  optional string error_message = 3;
  // on success, return the complete ExpectedMachine
  optional ExpectedMachine expected_machine = 4;
}

message BatchExpectedMachineOperationResponse {
  // Individual results for each ExpectedMachine
  repeated ExpectedMachineOperationResult results = 1;
}

message MachineRebootCompletedResponse {
}

message MachineRebootCompletedRequest {
  common.MachineId machine_id = 1;
}
// enum MachineValidationState {
//     Started = 0;
//     InProgress = 1;
//     Completed = 2;
//     Skipped = 3;
//     Failed(string) = 4;
// }

message MachineValidationCompletedRequest {
  common.MachineId machine_id = 1;
  optional string machine_validation_error = 2;
  common.UUID validation_id = 3;
}

message MachineValidationCompletedResponse {
}

message MachineValidationResult {
  string name = 1;
  string description = 2;
  string command = 3;
  string args = 4;
  string std_out = 5;
  string std_err = 6;
  string context = 7;
  int32 exit_code = 8;
  google.protobuf.Timestamp start_time = 10;
  google.protobuf.Timestamp end_time = 11;
  common.UUID validation_id = 12;
  optional string test_id = 13;
}

message MachineValidationResultPostRequest {
  MachineValidationResult result = 1;
}

message MachineValidationResultList {
  repeated MachineValidationResult results = 1;
}

message MachineValidationGetRequest {
  optional common.MachineId machine_id = 1;
  bool include_history = 2;
  optional common.UUID validation_id = 3;
}

message MachineValidationStatus {

  enum MachineValidationStarted {
    Started = 0;
  }

  enum MachineValidationInProgress {
    InProgress = 0;
  }

  enum MachineValidationCompleted {
    Success = 0;
    Failed = 1;
    Skipped = 2;
  }

  oneof MachineValidationState {
    MachineValidationStarted started = 1;
    MachineValidationInProgress in_progress = 2;
    MachineValidationCompleted completed = 3;
  }

  uint32 total = 4;
  uint32 completed_tests = 5;
}
message MachineValidationRun {
  common.UUID validation_id = 1;
  common.MachineId machine_id = 2;
  google.protobuf.Timestamp start_time = 3;
  google.protobuf.Timestamp end_time = 4;
  string name = 5;
  optional string context = 6;
  MachineValidationStatus status = 7;
  google.protobuf.Duration duration_to_complete = 8;

}

message MachineSetAutoUpdateRequest {
  enum SetAutoupdateAction {
    Enable = 0;
    Disable = 1;
    Clear = 2;
  }

  common.MachineId machine_id = 1;
  SetAutoupdateAction action = 2;
}

message MachineSetAutoUpdateResponse {
}

message GetMachineValidationExternalConfigRequest {
  string name = 1;
}
message MachineValidationExternalConfig {
  string name = 1;
  optional string description = 2;
  bytes config = 3;
  string version = 4;
  google.protobuf.Timestamp timestamp = 5;
}

message  GetMachineValidationExternalConfigResponse {
  MachineValidationExternalConfig config = 1;
}

message GetMachineValidationExternalConfigsRequest {
  repeated string names = 1;
}
message  GetMachineValidationExternalConfigsResponse {
  repeated MachineValidationExternalConfig configs = 1;
}

message AddUpdateMachineValidationExternalConfigRequest {
  string name = 1;
  optional string description = 2;
  bytes config = 3;
}
message RemoveMachineValidationExternalConfigRequest {
  string name = 1;
}
message MachineValidationOnDemandRequest {
  common.MachineId machine_id = 1;
  repeated string tags = 2;
  enum Action {
    Start = 0;
    Stop = 1;
  }
  Action action = 3;
  repeated string allowed_tests = 4;
  bool run_unverfied_tests = 5;
  repeated string contexts = 6;
}

message MachineValidationOnDemandResponse {
  common.UUID validation_id = 1;
}

message AdminPowerControlRequest {
  enum SystemPowerControl {
    // Power on a machine
    On = 0;
    // Graceful host shutdown
    GracefulShutdown = 1;
    // Forcefully powers a machine off
    ForceOff = 2;
    // Graceful restart. Asks the OS to restart via ACPI
    GracefulRestart =3;
    // Force restart. This is equivalent to pressing the reset button on the front panel.
    ForceRestart = 4;
    // AC powercycle. This is equivalent to unplugging and reconnecting power cables. Not supported on Vikings.
    ACPowercycle = 5;
  }
  optional BmcEndpointRequest bmc_endpoint_request = 1;
  optional string machine_id = 2;
  SystemPowerControl action = 3;
}

message AdminPowerControlResponse {
  optional string msg = 1;
}

message GetRedfishJobStateRequest {
  common.MachineId machine_id = 1;
  string job_id = 2;
}

message GetRedfishJobStateResponse {
  enum RedfishJobState {
    Scheduled = 0;
    Running = 1;
    Completed = 2;
    CompletedWithErrors = 3;
    Unknown = 4;
  }
  RedfishJobState job_state = 1;
}

message MachineValidationRunList {
  repeated MachineValidationRun runs = 1;
}

message MachineValidationRunListGetRequest {
  common.MachineId machine_id = 1;
  bool include_history = 2;
}

message IsBmcInManagedHostResponse {
  bool in_managed_host = 1;
}

message BmcCredentialStatusResponse {
  bool have_credentials = 1;
}
message MachineValidationTestsGetRequest {
  repeated string supported_platforms = 1;
  repeated string contexts = 2;
  optional string test_id = 3;
  optional bool read_only = 4;
  repeated string custom_tags = 5;
  optional string version = 6;
  optional bool is_enabled = 7;
  optional bool verified = 8;
}
message MachineValidationTestUpdateRequest {
  message Payload {
    optional string name = 1;
    optional string description = 2;
    repeated string contexts = 3;
    optional string img_name = 4;
    optional bool execute_in_host = 5;
    optional string container_arg = 6;
    optional string command = 7;
    optional string args = 8;
    optional string extra_err_file = 9;
    optional string external_config_file = 10;
    optional string pre_condition = 11;
    optional int64 timeout = 12;
    optional string extra_output_file = 13;
    repeated string supported_platforms = 14;
    optional bool verified = 15;
    repeated string custom_tags = 16;
    repeated string components = 17;
    optional bool is_enabled = 19;
  }
  string test_id = 1;
  string version = 2;
  Payload payload = 3;
}

message MachineValidationTestAddRequest {
  string name = 1;
  optional string description = 2;
  repeated string contexts = 3;
  optional string img_name = 4;
  optional bool execute_in_host = 5;
  optional string container_arg = 6;
  string command = 7;
  string args = 8;
  optional string extra_err_file = 9;
  optional string external_config_file = 10;
  optional string pre_condition = 11;
  optional int64 timeout = 12;
  optional string extra_output_file = 13;
  repeated string supported_platforms = 14;
  optional bool read_only = 15;
  repeated string custom_tags = 16;
  repeated string components = 17;
  optional bool is_enabled = 18;
}
message MachineValidationTestAddUpdateResponse {
  string test_id = 1;
  string version = 2;
}

message MachineValidationTestsGetResponse {
  repeated MachineValidationTest tests = 1;
}

message MachineValidationTestVerfiedRequest {
  string test_id = 1;
  string version = 2;
}
message MachineValidationTestVerfiedResponse {
  string message = 1;
}
message MachineValidationTest {
  string test_id = 1;
  string name = 2;
  optional string description = 3;
  repeated string contexts = 4;
  optional string img_name = 5;
  optional bool execute_in_host = 6;
  optional string container_arg = 7;
  string command = 8;
  string args = 9;
  optional string extra_err_file = 10;
  optional string external_config_file = 11;
  optional string pre_condition = 12;
  optional int64 timeout = 13;
  optional string extra_output_file = 14;
  string version = 15;
  repeated string supported_platforms = 16;
  string modified_by = 17;
  bool verified = 18;
  bool read_only = 19;
  repeated string custom_tags = 20;
  repeated string components = 21;
  string last_modified_at = 22;
  bool is_enabled = 23;
}
message MachineValidationTestNextVersionResponse {
  string test_id = 1;
  string version = 2;
}
message MachineValidationTestNextVersionRequest {
  string test_id = 1;
}

message MachineValidationTestEnableDisableTestRequest {
  string test_id = 1;
  string version = 2;
  bool is_enabled = 3;
}

message MachineValidationTestEnableDisableTestResponse {
  string message = 1;
}

message MachineValidationRunRequest {
  common.UUID validation_id = 1;
  google.protobuf.Duration duration_to_complete = 2;
  uint32 total = 3;
}
message MachineValidationRunResponse {
  string message = 1;
}

enum MachineCapabilityDeviceType {
  MACHINE_CAPABILITY_DEVICE_TYPE_UNKNOWN = 0;
  MACHINE_CAPABILITY_DEVICE_TYPE_DPU = 1;
  MACHINE_CAPABILITY_DEVICE_TYPE_NVLINK = 2;
}

message MachineCapabilityAttributesCpu {
  string name               = 1;
  uint32 count              = 2;
  optional string vendor    = 3;
  reserved 4; // Was: frequency
  optional uint32 cores     = 5;
  optional uint32 threads   = 6;
}

message MachineCapabilityAttributesGpu {
  string name                     = 1;
  uint32 count                    = 2;
  optional string vendor          = 3;
  optional string frequency       = 4;
  optional string capacity        = 5; // Memory capacity
  optional uint32 cores           = 6;
  optional uint32 threads         = 7;
  optional MachineCapabilityDeviceType device_type = 8;
}

message MachineCapabilityAttributesMemory {
  string name                       = 1;
  uint32 count                      = 2;
  optional string vendor            = 3;
  optional string capacity          = 4;
}

message MachineCapabilityAttributesStorage {
  string name                       = 1;
  uint32 count                      = 2;
  optional string vendor            = 3;
  optional string capacity          = 4;
}

message MachineCapabilityAttributesNetwork {
  string name                                                   = 1;
  uint32 count                                                  = 2;
  optional string vendor                                        = 3;
  optional MachineCapabilityDeviceType device_type              = 4;
}

message MachineCapabilityAttributesInfiniband {
  string name                       = 1;
  uint32 count                      = 2;
  optional string vendor            = 3;
  // The indexes of InfiniBand Devices which are not active and thereby can
  // not be utilized by Instances.
  // Inactive devices are devices where for example there is no connection
  // between the port and the InfiniBand switch.
  // Example: A `{count: 4, inactive_devices: [1,3]}` means that the devices
  // with index `0` and `2` of the Host can be utilized, and devices with index
  // `1` and `3` can not be used.
  repeated uint32 inactive_devices  = 4;
}

message MachineCapabilityAttributesDpu {
  string name                       = 1;
  uint32 count                      = 2;
  optional string hardware_revision = 3;
}

message MachineCapabilitiesSet {
  repeated MachineCapabilityAttributesCpu cpu               = 1;
  repeated MachineCapabilityAttributesGpu gpu               = 2;
  repeated MachineCapabilityAttributesMemory memory         = 3;
  repeated MachineCapabilityAttributesStorage storage       = 4;
  repeated MachineCapabilityAttributesNetwork network       = 5;
  repeated MachineCapabilityAttributesInfiniband infiniband = 6;
  repeated MachineCapabilityAttributesDpu dpu               = 7;
}

message InstanceTypeAttributes {
  // The minimum set of capabilities that a machine
  // must have before it can be link with the specified
  // instance type.
  repeated InstanceTypeMachineCapabilityFilterAttributes desired_capabilities = 1;
}

// An InstanceType describes a desired set of
// machine capabilities.
// It's probably easiest to just think of InstanceType
// as a pool, and the desired capabilities of an InstanceType
// define which machines are allowed in the pool.
message InstanceType {
  string id                         = 1;
  InstanceTypeAttributes attributes = 2;
  string version                    = 3;
  Metadata metadata                 = 4;
  optional string created_at        = 5;
}

// These match the current set of distinct
// active types in Forge Cloud.
enum MachineCapabilityType {
  CAP_TYPE_INVALID    = 0;
  CAP_TYPE_CPU        = 1;
  CAP_TYPE_GPU        = 2;
  CAP_TYPE_MEMORY     = 3;
  CAP_TYPE_STORAGE    = 4;
  CAP_TYPE_NETWORK    = 5;
  CAP_TYPE_INFINIBAND = 6;
  CAP_TYPE_DPU        = 7;
}

// InstanceTypeMachineCapabilityFilterAttributes are the specific
// properties of ONE capability. For example, a InstanceType
// might have a CPU capability.  The attributes of that single
// capability might be type=CPU, name="Intel Xeon", cores=12,
// threads=24. For a machine to be allowed in to the pool for
// an InstanceType with that capability, the machine must also
// have a capability that matches those properties.
message InstanceTypeMachineCapabilityFilterAttributes {
  MachineCapabilityType capability_type                   = 1;
  optional string name                                    = 2; // Intel Xeon, Samsung SSD, etc.
  optional string frequency                               = 3; // E.g., 2.4GHz, 1024MHz, etc
  optional string capacity                                = 4; // E.g., 10GB, 256 MB, etc
  optional string vendor                                  = 5;
  optional uint32 count                                   = 6;
  optional string hardware_revision                       = 7;
  optional uint32 cores                                   = 8;
  optional uint32 threads                                 = 9;
  optional common.Uint32List inactive_devices             = 10;
  optional MachineCapabilityDeviceType device_type = 11; // Only used for network capabilities
}

message CreateInstanceTypeRequest {
  optional string id                              = 1;
  Metadata metadata                               = 2;
  InstanceTypeAttributes instance_type_attributes = 3;
}

message CreateInstanceTypeResponse {
  InstanceType instance_type = 1;
}

message FindInstanceTypeIdsRequest {
};

message FindInstanceTypeIdsResponse {
  repeated string instance_type_ids = 1;
}

message FindInstanceTypesByIdsRequest {
  repeated string instance_type_ids = 1;
}

message FindInstanceTypesByIdsResponse {
  repeated InstanceType instance_types = 1;
}

message DeleteInstanceTypeRequest {
  string id = 1;
}

message DeleteInstanceTypeResponse {
}

message UpdateInstanceTypeResponse {
  InstanceType instance_type = 1;
}

message UpdateInstanceTypeRequest {
  string id                                       = 1;
  Metadata metadata                               = 2;
  InstanceTypeAttributes instance_type_attributes = 3;
  optional string if_version_match                = 4;
}

message AssociateMachinesWithInstanceTypeRequest {
  string instance_type_id     = 1;
  repeated string machine_ids = 2;
}

message AssociateMachinesWithInstanceTypeResponse {
}

message RemoveMachineInstanceTypeAssociationRequest {
  string machine_id = 1;
}

message RemoveMachineInstanceTypeAssociationResponse {
}

message RedfishBrowseRequest {
  string uri = 1;
}

message RedfishBrowseResponse {
  // Response in JSON String
  string text = 1;
  map<string, string> headers = 2;
}

message RedfishListActionsRequest {
  optional string machine_ip = 4;
}

message RedfishListActionsResponse {
  repeated RedfishAction actions = 1;
}

message RedfishAction {
  int64 request_id = 1;
  string requester = 2;
  repeated string approvers = 3;
  repeated google.protobuf.Timestamp approver_dates = 4;
  repeated string machine_ips = 5;
  repeated string board_serials = 6;
  // The url target of the POST request.
  string target = 7;
  // The Redfish action name.
  string action = 8;
  // The json-encoded parameters to the Redfish action.
  string parameters = 9;
  optional google.protobuf.Timestamp applied_at = 10;
  optional string applier = 11;
  repeated OptionalRedfishActionResult results = 12;
}

message OptionalRedfishActionResult {
  optional RedfishActionResult result = 1;
}

message RedfishActionResult {
  map<string, string> headers = 1;
  string status = 2;
  string body = 3;
  google.protobuf.Timestamp completed_at = 4;
}

message RedfishCreateActionRequest {
  repeated string ips = 1;
  string action = 2;
  string target = 3;
  string parameters = 4;
}

message RedfishCreateActionResponse {
  int64 request_id = 1;
}

message RedfishActionID {
  int64 request_id = 1;
}

message RedfishApproveActionResponse {
}

message RedfishApplyActionResponse {
}

message RedfishCancelActionResponse {
}

message UfmBrowseRequest {
  // IB Fabric to query
  string fabric_id = 1;
  // Queried path on UFM
  string path = 2;
}

message UfmBrowseResponse {
  // Response body
  string body = 1;
  // Response status code
  int32 code = 2;
  // Response headers
  map<string, string> headers = 3;
}

message NetworkSecurityGroupAttributes {
  repeated NetworkSecurityGroupRuleAttributes rules = 1;

  // Whether egress rules should be stateful.
  bool stateful_egress                              = 2;
}

message NetworkSecurityGroup {
  string id                                 = 1;
  string tenant_organization_id             = 2;
  Metadata metadata                         = 3;
  string version                            = 4;
  NetworkSecurityGroupAttributes attributes = 5;
  optional string created_at                = 6;
  optional string created_by                = 7;
  optional string updated_by                = 8;
}

message CreateNetworkSecurityGroupRequest {
  optional string id                                               = 1;
  string tenant_organization_id                                    = 2;
  Metadata metadata                                                = 3;
  NetworkSecurityGroupAttributes network_security_group_attributes = 4;
}

message CreateNetworkSecurityGroupResponse {
  NetworkSecurityGroup network_security_group = 1;
}

message FindNetworkSecurityGroupIdsRequest {
  optional string name                   = 1;
  optional string tenant_organization_id = 2;
}

message FindNetworkSecurityGroupIdsResponse {
  repeated string network_security_group_ids = 1;
}

message FindNetworkSecurityGroupsByIdsRequest {
  repeated string network_security_group_ids = 1;
  optional string tenant_organization_id     = 2;
}

message FindNetworkSecurityGroupsByIdsResponse {
  repeated NetworkSecurityGroup network_security_groups = 1;
}

message UpdateNetworkSecurityGroupResponse {
  NetworkSecurityGroup network_security_group = 1;
}

message UpdateNetworkSecurityGroupRequest {
  string id                                                        = 1;
  string tenant_organization_id                                    = 2; // Unalterable.  Used only for restricting the query.
  Metadata metadata                                                = 3;
  optional string if_version_match                                 = 4;
  NetworkSecurityGroupAttributes network_security_group_attributes = 5;
}

message DeleteNetworkSecurityGroupRequest {
  string id                     = 1;
  string tenant_organization_id = 2; // Unalterable.  Used only for restricting the query.
}

message DeleteNetworkSecurityGroupResponse {
}

enum NetworkSecurityGroupSource {
  NSG_SOURCE_INVALID  = 0; // Should be rejected.  There is no default NSG source, and the reporter should be explicit about the source.
  NSG_SOURCE_NONE     = 1; // No NSG is applied: neither VPC, Instance, nor interface has an NSG configured.
  NSG_SOURCE_VPC      = 2; // NSG sourced from NSG configured on VPC.
  NSG_SOURCE_INSTANCE = 3; // NSG sourced from NSG configured on instance, which overrides VPC.
}

message NetworkSecurityGroupStatus {
  NetworkSecurityGroupSource source = 1;
  string id                         = 2;
  string version                    = 3;
}

enum NetworkSecurityGroupPropagationStatus {
  NSG_PROP_STATUS_UNKNOWN = 0; // The status could not be determined.
  NSG_PROP_STATUS_FULL    = 1; // Fully propagated across all related objects.
  NSG_PROP_STATUS_PARTIAL = 2; // Propagation across some related objects but not all. E.g., Two out of three instances.
  NSG_PROP_STATUS_NONE    = 3; // No issues, but no propagation has completed yet.
  NSG_PROP_STATUS_ERROR   = 4; // Propagation is in a failed state and will not complete.
}

message NetworkSecurityGroupPropagationObjectStatus {
  // The UUID of the VPC or instance.  If we decide to allow
  // per-interface NSG application later, this _could_ be used to
  // hold the interface index number, and an optional
  // parent_id field could be added to hold the instance id.
  string id                                    = 1;

  NetworkSecurityGroupPropagationStatus status = 2;
  optional string details                      = 3;

  // Any instances IDs related to the object
  // In the case of VPCs, it would be any instances
  // that do not have a more specific NSG applied at
  // the instance level.
  repeated string related_instance_ids         = 4;

  // Any instances IDs related to the object that
  // are negatively affecting the propagation status
  // of the object.
  // In the case of VPCs, it would be any instances
  // that do not have a more specific NSG applied at
  // the instance level and that do not have the
  // current NSG ID and version used by the parent
  // VPC.
  repeated string unpropagated_instance_ids    = 5;
}

message GetNetworkSecurityGroupPropagationStatusResponse {
  repeated NetworkSecurityGroupPropagationObjectStatus vpcs       = 1;
  repeated NetworkSecurityGroupPropagationObjectStatus instances  = 2;
}

message NetworkSecurityGroupIdList {
  repeated string ids = 3;
}

message GetNetworkSecurityGroupPropagationStatusRequest {
  // Used to check the propagation of NSGs applied to VPCs across
  // all interfaces of all instances under those VPCs.
  // This is checking observed network_security_group_version
  // of the interfaces with a source of VPC.
  repeated string vpc_ids                                        = 1;

  // Used to check the propagation of NSGs applied to instances
  // across all interfaces of those instances.
  // This is checking observed network_security_group_version
  // of the interfaces with a source of INSTANCE.
  repeated string instance_ids                                   = 2;

  // Used to restrict the status results to
  // objects with attachments to a specific set of
  // NetworkSecurityGroups
  optional NetworkSecurityGroupIdList network_security_group_ids = 3;
}

enum NetworkSecurityGroupRuleDirection {
  NSG_RULE_DIRECTION_INVALID = 0; // Must be rejected
  NSG_RULE_DIRECTION_INGRESS = 1;
  NSG_RULE_DIRECTION_EGRESS  = 2;
}

enum NetworkSecurityGroupRuleProtocol {
  NSG_RULE_PROTO_INVALID = 0; // Must be rejected
  NSG_RULE_PROTO_ANY     = 1;
  NSG_RULE_PROTO_ICMP    = 2;
  NSG_RULE_PROTO_UDP     = 3;
  NSG_RULE_PROTO_TCP     = 4;
  NSG_RULE_PROTO_ICMP6   = 5;
}

enum NetworkSecurityGroupRuleAction {
  NSG_RULE_ACTION_INVALID = 0; // Must be rejected
  NSG_RULE_ACTION_DENY    = 1;
  NSG_RULE_ACTION_PERMIT  = 2;
}

message NetworkSecurityGroupRuleAttributes {

  // Optionally sent in; otherwise, generated on creation.
  // Facilitates metrics/logging in the future.
  optional string id                          = 1;

  NetworkSecurityGroupRuleDirection direction = 2;
  bool ipv6                                   = 3;
  optional uint32 src_port_start              = 4;
  optional uint32 src_port_end                = 5;
  optional uint32 dst_port_start              = 6;
  optional uint32 dst_port_end                = 7;
  NetworkSecurityGroupRuleProtocol protocol   = 8;
  NetworkSecurityGroupRuleAction action       = 9;
  uint32 priority                             = 10;

  oneof source_net {
    string src_prefix                         = 11;
  }

  oneof destination_net {
    string dst_prefix                       = 12;
  }
}

// This holds the resulting rule after any
// object references have been resolved.
// For example, a rule that references a VPC ID
// would be resolved to the actual prefixes associated
// with that VPC.  This is the message that is
// actually used by the DPU to generate its NVUE config.
message ResolvedNetworkSecurityGroupRule {
  NetworkSecurityGroupRuleAttributes rule = 1;
  repeated string src_prefixes            = 2;
  repeated string dst_prefixes            = 3;
}

message GetNetworkSecurityGroupAttachmentsRequest {

  repeated string network_security_group_ids = 1;

}

message NetworkSecurityGroupAttachments {
  string network_security_group_id = 1;
  repeated string vpc_ids          = 2;
  repeated string instance_ids     = 3;
}

message GetNetworkSecurityGroupAttachmentsResponse {
  repeated NetworkSecurityGroupAttachments attachments = 1;
}

message GetDesiredFirmwareVersionsRequest {
}

message GetDesiredFirmwareVersionsResponse {
  repeated DesiredFirmwareVersionEntry entries = 1;
}

message DesiredFirmwareVersionEntry {
  string vendor = 1;
  string model = 2;
  map<string, string> component_versions = 3;
}

message SkuComponentChassis {
  string vendor = 1;
  string model = 2;
  string architecture = 3;
}

message SkuComponentCpu {
  string vendor = 1;
  string model = 2;
  uint32 thread_count = 3;
  uint32 count = 4;
}

message SkuComponentGpu {
  string vendor = 1;
  string model = 2;
  uint32 count = 3;
  string total_memory = 4;
}

message SkuComponentEthernetDevices {
  string vendor = 1;
  string model = 2;
  bool is_connected = 3;
  uint32 count = 4;
}

message SkuComponentInfinibandDevices {
  // The Vendor of the InfiniBand device. E.g. `Mellanox`
  string vendor = 1;
  // The Device Name of the InfiniBand device. E.g. `MT2910 Family [ConnectX-7]`
  string model = 2;
  // The total amount of InfiniBand devices of the given
  // vendor and model combination
  uint32 count = 3;
  // The indexes of InfiniBand Devices which are not active and thereby can
  // not be utilized by Instances.
  // Inactive devices are devices where for example there is no connection
  // between the port and the InfiniBand switch.
  // Example: A `{count: 4, inactive_devices: [1,3]}` means that the devices
  // with index `0` and `2` of the Host can be utilized, and devices with index
  // `1` and `3` can not be used.
  repeated uint32 inactive_devices = 4;
}

message SkuComponentStorage {
  string vendor = 1;
  string model = 2;
  uint32 count = 3;
  uint32 capacity_mb = 4;
}

message SkuComponentStorageController {
  string vendor = 1;
  string model = 2;
  uint32 count = 3;
}

message SkuComponentMemory {
  string memory_type = 1;
  uint32 capacity_mb = 2;
  uint32 count = 3;
}

message SkuComponentTpm {
  string vendor = 1;
  string version = 2;
}

message SkuComponents {
  SkuComponentChassis chassis = 1;
  repeated SkuComponentCpu cpus = 2;
  repeated SkuComponentGpu gpus = 3;
  repeated SkuComponentEthernetDevices ethernet_devices = 4;
  repeated SkuComponentInfinibandDevices infiniband_devices = 5;
  repeated SkuComponentStorage storage = 6;
  repeated SkuComponentMemory memory = 7;
  optional SkuComponentTpm tpm = 8;
}

message Sku {
  string id = 1;
  optional string description = 2;
  optional google.protobuf.Timestamp created = 3;
  SkuComponents components = 4;
  reserved 5;
  uint32 schema_version = 6;
  repeated common.MachineId associated_machine_ids = 7;
  optional string device_type = 8;
}

message SkuMachinePair {
  string sku_id = 1;
  common.MachineId machine_id = 2;
  bool force = 3;
}

message RemoveSkuRequest {
  common.MachineId machine_id = 1;
  bool force = 2;
}

message SkuList {
  repeated Sku skus = 1;
}

message SkuIdList {
  repeated string ids = 1;
}

message SkuStatus {
  optional google.protobuf.Timestamp verify_request_time = 1;
  optional google.protobuf.Timestamp last_match_attempt = 2;
  optional google.protobuf.Timestamp last_generate_attempt = 3;
}

message SkusByIdsRequest {
  repeated string ids = 1;
}

message SkuSearchFilter {
}

message DpaInterface {
  common.DpaInterfaceId id = 1;
  common.MachineId machine_id = 2;
  string mac_addr = 3;

  google.protobuf.Timestamp created = 4;
  google.protobuf.Timestamp updated = 5;
  google.protobuf.Timestamp deleted = 6;

  string controller_state = 7;
  string controller_state_version = 8;
  string controller_state_outcome = 9;
  string network_status_observation = 10;

  string network_config = 11;
  string network_config_version = 12;

  repeated DpaInterfaceStateHistoryRecord history = 13;

  google.protobuf.Timestamp last_hb_time = 14;

  string card_state = 15;
  string pci_name = 16;

  string underlay_ip = 17;
  string overlay_ip = 18;
}


message DpaInterfaceCreationRequest {
  common.MachineId machine_id = 1;
  string mac_addr = 2;
  string device_type = 3;
  string pci_name = 4;
}

message DpaInterfaceIdList {
  repeated common.DpaInterfaceId ids = 1;
}

message DpaInterfacesByIdsRequest {
  repeated common.DpaInterfaceId ids = 1;
  bool include_history = 2;
}

message DpaInterfaceList {
  repeated DpaInterface interfaces = 1;
}

message DpaInterfaceStateHistoryRecord {
  string state = 1;
  string version = 2;
  google.protobuf.Timestamp time = 3;
}

message DpaNetworkObservationSetRequest {
  common.DpaInterfaceId id = 1;
}

message DpaInterfaceDeletionRequest {
  common.DpaInterfaceId id = 1;
}

message DpaInterfaceDeletionResult {
}

message SkuUpdateMetadataRequest {
  string sku_id = 1;
  optional string description = 2;
  optional string device_type = 3;
}

message PowerOptionRequest {
  repeated common.MachineId machine_id = 1;
}

enum PowerState {
  On = 0;
  Off = 1;
  PowerManagerDisabled = 2;
}

message PowerOptionUpdateRequest {
  common.MachineId machine_id = 1;
  PowerState power_state = 2;
}

message PowerOptions {
  PowerState desired_state = 1;
  google.protobuf.Timestamp desired_state_updated_at = 2;
  PowerState actual_state = 3;
  google.protobuf.Timestamp actual_state_updated_at = 4;
  common.MachineId host_id = 5;
  string desired_power_state_version = 6;
  google.protobuf.Timestamp next_power_state_fetch_at = 7;
  int32 off_counter = 8;
  optional google.protobuf.Timestamp tried_triggering_on_at = 9;
  int32 tried_triggering_on_counter = 10;
  google.protobuf.Timestamp wait_until_time_before_performing_next_power_action = 11;
}

message PowerOptionResponse {
  repeated PowerOptions response = 1;
}

message GetRackRequest {
  optional string id = 1;
}

message GetRackResponse {
  repeated Rack rack = 1;
}

message Rack {
  common.RackId id = 1;
  string rack_state = 2;
  repeated string expected_compute_trays = 3;
  repeated string expected_power_shelves = 4;
  repeated string expected_nvlink_switches = 5;
  repeated common.MachineId compute_trays = 6;
  repeated common.PowerShelfId power_shelves = 7;
  // repeated common.NvlinkSwitchId nvlink_switches = 8;
  google.protobuf.Timestamp created = 9;
  google.protobuf.Timestamp updated = 10;
  google.protobuf.Timestamp deleted = 11;
}

message DeleteRackRequest {
  string id = 1;
}

// put some sample rack manager commands in for now
enum RackManagerForgeCmd {
  InventoryGet = 0;
  RemoveNode = 1;
  GetPoweronOrder = 2;
  GetPowerState = 3;
  GetFirmwareInventory = 4;
  GetAvailableFwImages = 5;
  GetBkcFiles = 6;
  CheckBkcCompliance = 7;
}

message RackManagerForgeRequest {
  RackManagerForgeCmd cmd = 1;
  optional string node_id = 2;
}

message RackManagerForgeResponse {
  optional string json_result = 1;
}
message MachineNVLinkInfo {
  common.NVLinkDomainId domain_uuid = 1;
  repeated NVLinkGpu gpus = 2;
}

message UpdateMachineNvLinkInfoRequest {
  common.MachineId machine_id = 1;
  MachineNVLinkInfo nvlink_info = 2;
}

message NVLinkGpu {
  string nmx_m_id = 1;
  int32 tray_index = 2;
  int32 slot_id = 3;
  int32 device_id = 4;
  uint64 guid = 5;
}

message MachineNVLinkStatusObservation {
  repeated MachineNVLinkGpuStatusObservation gpu_status = 1;
}

message MachineNVLinkGpuStatusObservation {
  string gpu_id = 1;
  optional common.NVLinkPartitionId partition_id = 2;
  optional common.NVLinkLogicalPartitionId logical_partition_id = 3;
  uint32 device_instance = 4;
  common.NVLinkDomainId domain_id = 5;
  uint64 guid = 6;
}

message NmxmBrowseRequest {
  string path = 1;
}

message NmxmBrowseResponse {
  // Response body
  string body = 1;
  // Response status code
  int32 code = 2;
  // Response headers
  map<string, string> headers = 3;
}

// Describe an NVLink based Partition configuration and status
message NVLinkPartition {
  common.NVLinkPartitionId id = 1;
  string name = 2;
  string nmx_m_id = 3;
  common.NVLinkDomainId domain_uuid = 4;
  common.NVLinkLogicalPartitionId logical_partition_id = 5;
}

message NVLinkPartitionList {
  repeated NVLinkPartition partitions = 1;
}

message NVLinkPartitionSearchConfig {
  bool include_history = 1;
}

message NVLinkPartitionQuery {
  common.UUID id = 1;
  optional NVLinkPartitionSearchConfig search_config = 2;
}

message NVLinkPartitionSearchFilter {
  optional string tenant_organization_id = 1;
  optional string name = 2;
}

message NVLinkPartitionsByIdsRequest {
  repeated common.NVLinkPartitionId partition_ids = 1;
  bool include_history = 2;
}

message NVLinkPartitionIdList {
  repeated common.NVLinkPartitionId partition_ids = 1;
}

message NVLinkFabricSearchFilter {
}

// Describe the desired configuration of an Logical Partition
message NVLinkLogicalPartitionConfig {
  Metadata metadata = 1;
  // The ID of tenant that NVLPartition belong to
  string tenant_organization_id = 2;
}

// Describe the status and applied configuration of an Logical Partition
message NVLinkLogicalPartitionStatus {
  // Provisioning state of this partition
  TenantState state = 1;
}

// Describe a Logical Partition configuration and status
message NVLinkLogicalPartition {
  common.NVLinkLogicalPartitionId id = 1;
  NVLinkLogicalPartitionConfig config = 2;

  string config_version = 3;

  NVLinkLogicalPartitionStatus status = 4;
}

message NVLinkLogicalPartitionList {
  repeated NVLinkLogicalPartition partitions = 1;
}

message NVLinkLogicalPartitionCreationRequest {
  NVLinkLogicalPartitionConfig config = 1;
  // Desired ID for this Partition. If the ID is not provided, Forge will generate
  // a random ID.
  // The Partition ID must be unique within the Forge site.
  optional common.NVLinkLogicalPartitionId id = 2;
}

message NVLinkLogicalPartitionDeletionRequest {
  common.NVLinkLogicalPartitionId id = 1;
}

message NVLinkLogicalPartitionDeletionResult {
}

message NVLinkLogicalPartitionSearchFilter {
  optional string name = 1;
}

message NVLinkLogicalPartitionsByIdsRequest {
  repeated common.NVLinkLogicalPartitionId partition_ids = 1;
  bool include_history = 2;
}

message NVLinkLogicalPartitionIdList {
  repeated common.NVLinkLogicalPartitionId partition_ids = 1;
}

message NVLinkLogicalPartitionUpdateRequest {
  common.NVLinkLogicalPartitionId id = 1;
  NVLinkLogicalPartitionConfig config = 2;
  optional string if_version_match = 3;
}

message NVLinkLogicalPartitionUpdateResult {
}

// Must provide either machine_id or ip/mac pair
message CreateBmcUserRequest {
  optional BmcEndpointRequest bmc_endpoint_request = 1;
  optional string machine_id = 2;
  string create_username = 3;
  string create_password = 4;
  optional string create_role_id = 5;
}

message CreateBmcUserResponse {
}


message DeleteBmcUserRequest {
  optional BmcEndpointRequest bmc_endpoint_request = 1;
  optional string machine_id = 2;
  string delete_username = 3;
}

message DeleteBmcUserResponse {
}

message SetFirmwareUpdateTimeWindowRequest {
  repeated common.MachineId machine_ids = 1;
  google.protobuf.Timestamp start_timestamp = 2;
  google.protobuf.Timestamp end_timestamp = 3;
}

message SetFirmwareUpdateTimeWindowResponse {
}

message ListHostFirmwareRequest {
}

message ListHostFirmwareResponse {
  repeated AvailableHostFirmware available = 1;
}

message AvailableHostFirmware {
  string vendor = 1;
  string model = 2;
  string type = 3;
  string inventory_name_regex = 4;
  string version = 5;
  bool needs_explicit_start = 6;
}

enum TrimTableTarget {
  MeasuredBoot = 0;
}

message TrimTableRequest{
  TrimTableTarget target = 1;
  uint32 keep_entries = 2;
}

message TrimTableResponse{
  string total_deleted = 1;
}

// begin DPU remediation models
message CreateRemediationRequest{
  string script = 1;
  Metadata metadata = 2;
  int32 retries = 3;
}
message CreateRemediationResponse {
  common.RemediationId remediation_id = 1;
}
message RemediationIdList {
  repeated common.RemediationId remediation_ids = 1;
}
message RemediationList {
  repeated Remediation remediations = 1;
}

message Remediation {
  common.RemediationId id = 1;
  Metadata metadata = 2;
  google.protobuf.Timestamp creation_time = 3;
  string script_author = 4;
  optional string script_reviewed_by = 5;
  string script = 6;
  bool enabled = 7;
  int32 retries = 8;
}

message ApproveRemediationRequest {
  common.RemediationId remediation_id = 1;
}
message RevokeRemediationRequest {
  common.RemediationId remediation_id = 1;
}
message EnableRemediationRequest {
  common.RemediationId remediation_id = 1;
}
message DisableRemediationRequest {
  common.RemediationId remediation_id = 1;
}

/// you can look up by *either* the remediation_id *or* the dpu_machine_id,
/// and the api server will give you back the other one(s).
message FindAppliedRemediationIdsRequest {
  optional common.RemediationId remediation_id = 1;
  optional common.MachineId dpu_machine_id = 2;
}
message AppliedRemediationIdList {
  repeated common.RemediationId remediation_ids = 1;
  repeated common.MachineId dpu_machine_ids = 2;
}
message FindAppliedRemediationsRequest {
  common.RemediationId remediation_id = 1;
  common.MachineId dpu_machine_id = 2;
}
message AppliedRemediation {
  common.RemediationId remediation_id = 1;
  common.MachineId dpu_machine_id = 2;
  int32 attempt = 3;
  bool succeeded = 4;
  google.protobuf.Timestamp applied_time = 5;
  Metadata metadata = 6; // only the labels will be populated.
}
message AppliedRemediationList {
  repeated AppliedRemediation applied_remediations = 1;
}

message GetNextRemediationForMachineRequest {
  common.MachineId dpu_machine_id = 1;
}
message GetNextRemediationForMachineResponse {
  optional common.RemediationId remediation_id = 1;
  optional string remediation_script = 2;
}
message RemediationAppliedRequest {
  common.RemediationId remediation_id = 1;
  common.MachineId dpu_machine_id = 2;
  RemediationApplicationStatus status = 3;
}
message RemediationApplicationStatus {
  bool succeeded = 1;
  Metadata metadata = 2; // the name/description is ignored, only using the labels for status persistence.
}
// end DPU remediation models

message SetPrimaryDpuRequest {
  common.MachineId host_machine_id = 1;
  common.MachineId dpu_machine_id = 2;
  bool reboot=3;
}

// DPU Extension Service Types and Messages
enum DpuExtensionServiceType {
  KUBERNETES_POD = 0;
  // Add supported service types in the future
}

message UsernamePassword {
  string username = 1;
  string password = 2;
}

message DpuExtensionServiceCredential {
  string registry_url = 1;

  oneof type {
    UsernamePassword username_password = 2;
    // @TODO: add more credential types in the future
  }
}

message DpuExtensionServiceVersionInfo {
  string version = 1;
  string data = 2;
  bool has_credential = 3;
  string created = 4;
  optional DpuExtensionServiceObservability observability = 5;
}

message DpuExtensionService {
  string service_id = 1;

  DpuExtensionServiceType service_type = 2;

  string service_name = 3;

  string tenant_organization_id = 4;

  // Tracks how many versions has ever been created for this extension service.
  // This is always incremented and is not always equal to the latest version since versions
  // can be deleted.
  int32 version_ctr = 5;

  // The information of the latest version of the extension service among all non-deleted versions.
  optional DpuExtensionServiceVersionInfo latest_version_info = 6;

  // All versions of the extension service that's not deleted.
  repeated string active_versions = 7;

  string description = 8;
  string created = 9;
  string updated = 10;
}

message CreateDpuExtensionServiceRequest {
  // Metadata
  optional string service_id = 1; // If not provided, a new UUID will be generated
  string service_name = 2;
  optional string description = 3;
  DpuExtensionServiceType service_type = 4; // Immutable

  string tenant_organization_id = 5; // Immutable

  // Versioned extension service spec
  string data = 6;
  optional DpuExtensionServiceCredential credential = 7;

  // Metrics configuration to be added to the existing
  // metrics collection service that runs on the DPU.
  optional DpuExtensionServiceObservability observability = 8;
}

message UpdateDpuExtensionServiceRequest {
  string service_id = 1;

  // optionally update the extension service metadata
  optional string service_name = 2;
  optional string description = 3;

  // create a new extension service version
  string data = 4;
  optional DpuExtensionServiceCredential credential = 5;
  // If the field here is set, the update will only be applied if the version
  // is equivalent to the current version on the Forge Site.
  // If a concurrent update changed the site configuration, the API will return
  // a `ConcurrentModificationError`.
  optional int32 if_version_ctr_match = 6;

  // Metrics configuration to be added to the existing
  // metrics collection service that runs on the DPU.
  optional DpuExtensionServiceObservability observability = 7;
}

// If versions is empty, request to delete the whole service;
// otherwise, request to delete the specified versions **but**
// if all versions are deleted, the service will be deleted.
message DeleteDpuExtensionServiceRequest {
  string service_id = 1;
  repeated string versions = 2;
}

message DeleteDpuExtensionServiceResponse {
}

message DpuExtensionServiceSearchFilter {
  optional DpuExtensionServiceType service_type = 1;
  optional string name = 2;
  optional string tenant_organization_id = 3;
}

message DpuExtensionServiceIdList {
  repeated string service_ids = 1;
}

message DpuExtensionServicesByIdsRequest {
  repeated string service_ids = 1;
}

message DpuExtensionServiceList {
  repeated DpuExtensionService services = 1;
}

// If versions is empty, request to get all versions of the extension service
message GetDpuExtensionServiceVersionsInfoRequest {
  string service_id = 1;
  repeated string versions = 2;
}

message DpuExtensionServiceVersionInfoList {
  repeated DpuExtensionServiceVersionInfo version_infos = 1;
}

enum DpuExtensionServiceDeploymentStatus {
  DPU_EXTENSION_SERVICE_UNKNOWN = 0;
  DPU_EXTENSION_SERVICE_PENDING = 1;
  DPU_EXTENSION_SERVICE_RUNNING = 2;
  DPU_EXTENSION_SERVICE_TERMINATING = 3;
  DPU_EXTENSION_SERVICE_TERMINATED = 4;
  DPU_EXTENSION_SERVICE_FAILED = 5;
  DPU_EXTENSION_SERVICE_ERROR = 6;
}

message FindInstancesByDpuExtensionServiceRequest {
  string service_id = 1;
  optional string version = 2;
}

message FindInstancesByDpuExtensionServiceResponse {
  repeated InstanceDpuExtensionServiceInfo instances = 1;
}

message InstanceDpuExtensionServiceInfo {
  string instance_id = 1;
  string service_id = 2;
  string version = 3;
  optional string removed = 4; // Signals that this service is being removed from instance config and is terminating
}

message DpuExtensionServiceObservabilityConfigPrometheus {
  uint32 scrape_interval_seconds = 1;
  string endpoint                = 2;
}

message DpuExtensionServiceObservabilityConfigLogging {
  string path = 1;
}

message DpuExtensionServiceObservabilityConfig {
  // The name of service being monitored OR the name of
  // the portion of the service being monitored.
  // This will default to the name of the service.
  optional string name = 1;

  oneof config {
    DpuExtensionServiceObservabilityConfigPrometheus prometheus = 2;
    DpuExtensionServiceObservabilityConfigLogging    logging    = 3;
  }
}


message DpuExtensionServiceObservability {
  repeated DpuExtensionServiceObservabilityConfig configs = 1;
}

// ScoutStreamApiBoundMessage is sent as part of scout initiating a new
// streaming gRPC connection with carbide-api. The agent will connect
// and sent an InitRequest, and then wait for control messages from
// the API. For example, the API will send down a MlxDeviceLockdownStatusRequest,
// and scout will populate an MlxDeviceLockdownStatusResponse and send
// it back over the stream.
message ScoutStreamApiBoundMessage {
  // flow_uuid is used to track the oneshot channel flow unique to this
  // specific request/response flow over the streaming connection. The
  // ScoutStreamScoutBoundMessage populates the initial flow_uuid, and this must
  // populate the same UUID.
  common.UUID flow_uuid = 1;

  oneof payload {
    // ScoutStreamInitRequest is sent as the first message to establish
    // a connection between a scout agent and carbide-api. After this,
    // carbide-api will populate a "request" within a ScoutStreamScoutBoundMessage,
    // send it to the scout agent, and expect the scout agent to respond
    // with a "response" from the oneof ScoutStreamApiBoundMessage options below.
    //
    // For information about all other messages, see the docstrings
    // associated with each message type.
    ScoutStreamInitRequest init = 2;
    mlx_device.MlxDeviceLockdownResponse mlx_device_lockdown_response = 3;
    mlx_device.MlxDeviceProfileSyncResponse mlx_device_profile_sync_response = 4;
    mlx_device.MlxDeviceProfileCompareResponse mlx_device_profile_compare_response = 5;
    mlx_device.MlxDeviceInfoDeviceResponse mlx_device_info_device_response = 6;
    mlx_device.MlxDeviceInfoReportResponse mlx_device_info_report_response = 7;
    mlx_device.MlxDeviceRegistryListResponse mlx_device_registry_list_response = 8;
    mlx_device.MlxDeviceRegistryShowResponse mlx_device_registry_show_response = 9;
    mlx_device.MlxDeviceConfigQueryResponse mlx_device_config_query_response = 10;
    mlx_device.MlxDeviceConfigSetResponse mlx_device_config_set_response = 11;
    mlx_device.MlxDeviceConfigSyncResponse mlx_device_config_sync_response = 12;
    mlx_device.MlxDeviceConfigCompareResponse mlx_device_config_compare_response = 13;
    ScoutStreamAgentPingResponse scout_stream_agent_ping_response = 14;
  }
}

// ScoutStreamScoutBoundMessage contains the requests from carbide-api
// that a connected scout agent should process and respond to,
// populating a response from one of the ScoutStreamApiBoundMessages.
message ScoutStreamScoutBoundMessage {
  // flow_uuid is used to track the oneshot channel flow unique to this
  // specific request/response flow over the streaming connection. The
  // ScoutStreamApiBoundMessage provided the value which is populated here.
  common.UUID flow_uuid = 1;

  // For information about each message type, see the docstrings
  // associated with the corresponding type.
  oneof payload {
    mlx_device.MlxDeviceLockdownLockRequest mlx_device_lockdown_lock_request = 2;
    mlx_device.MlxDeviceLockdownUnlockRequest mlx_device_lockdown_unlock_request = 3;
    mlx_device.MlxDeviceLockdownStatusRequest mlx_device_lockdown_status_request = 4;
    mlx_device.MlxDeviceProfileSyncRequest mlx_device_profile_sync_request = 5;
    mlx_device.MlxDeviceProfileCompareRequest mlx_device_profile_compare_request = 6;
    mlx_device.MlxDeviceInfoDeviceRequest mlx_device_info_device_request = 7;
    mlx_device.MlxDeviceInfoReportRequest mlx_device_info_report_request = 8;
    mlx_device.MlxDeviceRegistryListRequest mlx_device_registry_list_request = 9;
    mlx_device.MlxDeviceRegistryShowRequest mlx_device_registry_show_request = 10;
    mlx_device.MlxDeviceConfigQueryRequest mlx_device_config_query_request = 11;
    mlx_device.MlxDeviceConfigSetRequest mlx_device_config_set_request = 12;
    mlx_device.MlxDeviceConfigSyncRequest mlx_device_config_sync_request = 13;
    mlx_device.MlxDeviceConfigCompareRequest mlx_device_config_compare_request = 14;
    ScoutStreamAgentPingRequest scout_stream_agent_ping_request = 15;
  }
}

// ScoutStreamInitRequest is sent by the scout agent to identify itself
// and establish a connection to carbide-api.
message ScoutStreamInitRequest {
  common.MachineId machine_id = 1;
}

// ScoutStreamShowConnectionsRequest is sent to request information
// about all established scout agent connections.
message ScoutStreamShowConnectionsRequest {
}

// ShowConnectionsResponse is the response containing active
// scout agent connection information.
message ScoutStreamShowConnectionsResponse {
  repeated ScoutStreamConnectionInfo scout_stream_connections = 1;
}

// ScoutStreamDisconnectRequest is sent to request closing the
// ScoutStream connection of a given machine ID.
message ScoutStreamDisconnectRequest {
  common.MachineId machine_id = 1;
}

// ScoutStreamDisconnectResponse is a response to an attempt
// to disconnect a machine's ScoutStream connection.
message ScoutStreamDisconnectResponse {
  common.MachineId machine_id = 1;
  bool success = 2;
}

// ScoutStreamAdminPingRequest is sent to check the liveliness
// of the scout agent by attempting to get back a pong. This
// comes from an administrative caller.
message ScoutStreamAdminPingRequest {
  common.MachineId machine_id = 1;
}

// ScoutStreamAdminPingResponse is hopefully a response from
// the scout agent to the administrative caller.
message ScoutStreamAdminPingResponse {
  string pong = 1;
}

// ScoutStreamAgentPingRequest is sent to check the liveliness
// of the scout agent by attempting to get back a pong. This
// comes from the API -> scout.
message ScoutStreamAgentPingRequest {
}

// ScoutStreamAgentPingResponse is hopefully a response from
// the scout agent. This is from scout -> API.
message ScoutStreamAgentPingResponse {
  oneof reply {
    string pong = 1;
    ScoutStreamError error = 2;
  }
}

// ScoutStreamConnectionInfo contains information about an
// active scout agent connection.
message ScoutStreamConnectionInfo {
  common.MachineId machine_id = 1;
  // connected_at contains an RFC3339 timestamp
  // showing when the scout agent first established a connection.
  string connected_at = 2;
  // uptime_seconds is just a convenience field with
  // the number of seconds the scout agent has been connected.
  uint64 uptime_seconds = 3;
}

// ScoutStreamError is a mechanism to send an error back over the stream,
// since you can't send status errors over established bidirectional
// streams.
message ScoutStreamError {
  ScoutStreamErrorStatus status = 1;
  string message = 2;
}

// ScoutStreamErrorStatus is an internal code to set to help
// with troubleshooting and debugging.
enum ScoutStreamErrorStatus {
  SCOUT_STREAM_ERROR_STATUS_INTERNAL = 0;
}


enum RoutingProfileType {
  ROUTING_PROFILE_TYPE_EXTERNAL            = 0; // Default to least privileged
  ROUTING_PROFILE_TYPE_ADMIN               = 1;
  ROUTING_PROFILE_TYPE_INTERNAL            = 2;
  ROUTING_PROFILE_TYPE_PRIVILEGED_INTERNAL = 3;
  ROUTING_PROFILE_TYPE_MAINTENANCE         = 4;
}

message RoutingProfile {
  repeated common.RouteTarget route_target_imports     = 1;
  repeated common.RouteTarget route_targets_on_exports = 2;
}

// ============================================================================
// LEGACY DNS/DOMAIN TYPES - DEPRECATED
// These types are maintained for backward compatibility
// New code should use the types defined in dns.proto
// TODO : Remove these types after migration is complete
// ============================================================================

// DEPRECATED: Use dns.Domain instead
message DomainLegacy {
  common.DomainId id = 1;
  string name = 2;
  google.protobuf.Timestamp created = 3;
  google.protobuf.Timestamp updated = 4;
  google.protobuf.Timestamp deleted = 5;
}

// DEPRECATED: Use dns.DomainList instead
message DomainListLegacy {
  repeated DomainLegacy domains = 1;
}

// DEPRECATED: Use dns.DomainDeletionRequest instead
message DomainDeletionLegacy {
  common.DomainId id = 1;
}

// DEPRECATED: Use dns.DomainDeletionResult instead
message DomainDeletionResultLegacy {

}

// DEPRECATED: Use dns.DomainSearchQuery instead
message DomainSearchQueryLegacy {
  optional common.DomainId id = 1;
  optional string name = 2;
}

// Temporary wrapper around both domain types while we transition
// TODO: Remove after migration is complete
message PxeDomain {
  oneof domain {
    dns.Domain new_domain = 1;
    Domain legacy_domain = 2;
  }
}


message MachinePositionQuery {
  repeated common.MachineId machine_ids = 1;
}

message MachinePositionInfoList {
  repeated MachinePositionInfo machine_position_info = 1;
}

message MachinePositionInfo {
  common.MachineId machine_id = 1;
  optional int32 physical_slot_number = 2;
  optional int32 compute_tray_index = 3;
  optional int32 topology_id = 4;
  optional int32 revision_id = 5;
  optional common.SwitchId switch_id = 6;
  optional common.PowerShelfId power_shelf_id = 7;
}

// Rack Firmware Management Messages

message RackFirmware {
  string id = 1;
  string config_json = 2;
  bool available = 3;
  string created = 4;
  string updated = 5;
  string parsed_components = 6; // JSON string of firmware lookup table
}

message FirmwareComponentInfo {
  string device_type = 1;
  string component = 2;
  string bundle = 3;
  string filename = 4;
  string target = 5;
  string firmware_type = 6; // "prod" or "dev"
}

message RackFirmwareCreateRequest {
  string config_json = 1;
  string artifactory_token = 2;
}

message RackFirmwareGetRequest {
  string id = 1;
}

message RackFirmwareListRequest {
  bool only_available = 1;
}

message RackFirmwareList {
  repeated RackFirmware configs = 1;
}

message RackFirmwareDeleteRequest {
  string id = 1;
}

message RackFirmwareApplyRequest {
  common.RackId rack_id = 1;
  string firmware_id = 2;
  string firmware_type = 3; // "dev" or "prod"
}

message RackFirmwareApplyResponse {
  int32 total_updates = 1;
  int32 successful_updates = 2;
  int32 failed_updates = 3;
  repeated DeviceUpdateResult device_results = 4;
}

message DeviceUpdateResult {
  string device_id = 1;
  string device_type = 2;
  bool success = 3;
  string message = 4;
}

message ModifyDPFStateRequest {
  common.MachineId machine_id = 1;
  bool dpf_enabled = 2;
}

message DPFStateResponse {
  message DPFState {
    common.MachineId machine_id = 1;
    bool dpf_enabled = 2;
  }
  repeated DPFState dpf_states = 1;
}

message GetDPFStateRequest {
  repeated common.MachineId machine_ids = 1;
}
